<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>My first Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">概要</a></li><li class="chapter-item expanded "><a href="section-2-using-parsers.html"><strong aria-hidden="true">1.</strong> パーサを使う</a></li><li class="chapter-item expanded "><a href="section-3-creating-parsers.html"><strong aria-hidden="true">2.</strong> パーサを作る</a></li><li class="chapter-item expanded "><a href="section-4-syntax-highlighting.html"><strong aria-hidden="true">3.</strong> シンタックスハイライト</a></li><li class="chapter-item expanded "><a href="section-5-implementation.html"><strong aria-hidden="true">4.</strong> 実装</a></li><li class="chapter-item expanded "><a href="section-6-contributing.html"><strong aria-hidden="true">5.</strong> コントリビュート</a></li><li class="chapter-item expanded "><a href="section-7-playground.html"><strong aria-hidden="true">6.</strong> Playground</a></li><li class="chapter-item expanded "><a href="section-8-code-navigation-systems.html"><strong aria-hidden="true">7.</strong> コードナビゲーションシステム</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">My first Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- textlint-disable -->
<p><a href="../README.html">目次</a> ----&gt;&gt; <a href="./section-2-using-parsers.html">次のページ(パーサを使う)</a></p>
<!-- textlint-enable -->
<h1><a class="header" href="#概要" id="概要">概要</a></h1>
<p>Tree-sitterはパーサ生成ツールであり、インクリメンタル解析をサポートする構文解析ライブラリである。
ソースファイルに対して具象構文木を構築し、ソースファイルの編集に伴って構文木を効率的に更新できる。Tree-sitterの目指すところは、以下の通り。</p>
<ul>
<li><strong>汎用</strong>: あらゆるプログラミング言語の解析に対応する。</li>
<li><strong>高速</strong>: テキストエディタでキーストロークごとに解析できる。</li>
<li><strong>頑健</strong>: 入力に構文スエラーがあっても有用な結果を提供できる。</li>
<li><strong>依存性の低さ</strong>: ランタイムライブラリがC言語で書かれており、あらゆるアプリケーションに組み込める。</li>
</ul>
<h3><a class="header" href="#バインディング" id="バインディング">バインディング</a></h3>
<p>現在、以下の言語からTree-sitterを利用するためのバインディングが用意されている。</p>
<ul>
<li><a href="https://github.com/tree-sitter/csharp-tree-sitter">C#</a></li>
<li><a href="https://github.com/smacker/go-tree-sitter">Go</a></li>
<li><a href="https://github.com/Z572/guile-ts">Guile</a></li>
<li><a href="https://github.com/tree-sitter/haskell-tree-sitter">Haskell</a></li>
<li><a href="https://github.com/serenadeai/java-tree-sitter">Java</a></li>
<li><a href="https://github.com/bonede/tree-sitter-ng">Java</a></li>
<li><a href="https://github.com/AndroidIDEOfficial/android-tree-sitter">Java (Android)</a></li>
<li><a href="https://github.com/tree-sitter/node-tree-sitter">JavaScript (Node.js)</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web">JavaScript (Wasm)</a></li>
<li><a href="https://github.com/oxisto/kotlintree">Kotlin</a></li>
<li><a href="https://github.com/euclidianAce/ltreesitter">Lua</a></li>
<li><a href="https://github.com/returntocorp/ocaml-tree-sitter-core">OCaml</a></li>
<li><a href="https://github.com/laytan/odin-tree-sitter">Odin</a></li>
<li><a href="https://metacpan.org/pod/Text::Treesitter">Perl</a></li>
<li><a href="https://github.com/tree-sitter/py-tree-sitter">Python</a></li>
<li><a href="https://github.com/Faveod/ruby-tree-sitter">Ruby</a></li>
<li><a href="https://github.com/calicoday/ruby-tree-sitter-ffi">Ruby</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust">Rust</a></li>
<li><a href="https://github.com/ChimeHQ/SwiftTreeSitter">Swift</a></li>
</ul>
<h3><a class="header" href="#パーサ" id="パーサ">パーサ</a></h3>
<!-- textlint-disable -->
<ul>
<li><a href="https://github.com/briot/tree-sitter-ada">Ada</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-agda">Agda</a></li>
<li><a href="https://github.com/aheber/tree-sitter-sfapex">Apex</a></li>
<li><a href="https://github.com/jsuarez-chipiron/tree-sitter-apex">ApexCode</a></li>
<li><a href="https://github.com/3p3r/tree-sitter-eventrule">AWS Event Rule</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-bash">Bash</a></li>
<li><a href="https://github.com/zwpaper/tree-sitter-beancount">Beancount</a></li>
<li><a href="https://github.com/amaanq/tree-sitter-capnp">Cap'n Proto</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-c">C</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-cpp">C++</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-c-sharp">C#</a></li>
<li><a href="https://github.com/bufbuild/tree-sitter-cel">CEL</a></li>
<li><a href="https://github.com/sogaiu/tree-sitter-clojure">Clojure</a></li>
<li><a href="https://github.com/uyha/tree-sitter-cmake">CMake</a></li>
<li><a href="https://github.com/yutaro-sakamoto/tree-sitter-cobol">COBOL</a></li>
<li><a href="https://github.com/theHamsta/tree-sitter-commonlisp">Common Lisp</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-css">CSS</a></li>
<li><a href="https://github.com/theHamsta/tree-sitter-cuda">CUDA</a></li>
<li><a href="https://github.com/UserNobody14/tree-sitter-dart">Dart</a></li>
<li><a href="https://github.com/gdamore/tree-sitter-d">D</a></li>
<li><a href="https://github.com/camdencheek/tree-sitter-dockerfile">Dockerfile</a></li>
<li><a href="https://github.com/rydesun/tree-sitter-dot">DOT</a></li>
<li><a href="https://github.com/elixir-lang/tree-sitter-elixir">Elixir</a></li>
<li><a href="https://github.com/elm-tooling/tree-sitter-elm">Elm</a></li>
<li><a href="https://github.com/Wilfred/tree-sitter-elisp">Emacs Lisp</a></li>
<li><a href="https://github.com/eno-lang/tree-sitter-eno">Eno</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-embedded-template">ERB / EJS</a></li>
<li><a href="https://github.com/WhatsApp/tree-sitter-erlang/">Erlang</a></li>
<li><a href="https://github.com/travonted/tree-sitter-fennel">Fennel</a></li>
<li><a href="https://github.com/ram02z/tree-sitter-fish">Fish</a></li>
<li><a href="https://github.com/siraben/tree-sitter-formula">Formula</a></li>
<li><a href="https://github.com/stadelmanma/tree-sitter-fortran">Fortran</a></li>
<li><a href="https://github.com/ObserverOfTime/tree-sitter-gitattributes">gitattributes</a></li>
<li><a href="https://github.com/shunsambongi/tree-sitter-gitignore">gitignore</a></li>
<li><a href="https://github.com/gleam-lang/tree-sitter-gleam">Gleam</a></li>
<li><a href="https://github.com/theHamsta/tree-sitter-glsl">GLSL (OpenGL Shading Language)</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-go">Go</a></li>
<li><a href="https://github.com/camdencheek/tree-sitter-go-mod">Go mod</a></li>
<li><a href="https://github.com/omertuc/tree-sitter-go-work">Go work</a></li>
<li><a href="https://github.com/bkegley/tree-sitter-graphql">GraphQL</a></li>
<li><a href="https://github.com/slackhq/tree-sitter-hack">Hack</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-haskell">Haskell</a></li>
<li><a href="https://github.com/MichaHoffmann/tree-sitter-hcl">HCL</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-html">HTML</a></li>
<li><a href="https://github.com/fab4100/tree-sitter-ispc">ISPC</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-java">Java</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-javascript">JavaScript</a></li>
<li><a href="https://github.com/flurie/tree-sitter-jq">jq</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-json">JSON</a></li>
<li><a href="https://github.com/Joakker/tree-sitter-json5">JSON5</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-julia">Julia</a></li>
<li><a href="https://github.com/IndianBoy42/tree-sitter-just">Just</a></li>
<li><a href="https://github.com/fwcd/tree-sitter-kotlin">Kotlin</a></li>
<li><a href="https://github.com/traxys/tree-sitter-lalrpop">LALRPOP</a></li>
<li><a href="https://github.com/latex-lsp/tree-sitter-latex">LaTeX</a></li>
<li><a href="https://github.com/Julian/tree-sitter-lean">Lean</a></li>
<li><a href="https://github.com/benwilliamgraham/tree-sitter-llvm">LLVM</a></li>
<li><a href="https://github.com/Flakebi/tree-sitter-llvm-mir">LLVM MachineIR</a></li>
<li><a href="https://github.com/artagnon/tree-sitter-mlir">LLVM MLIR</a></li>
<li><a href="https://github.com/Flakebi/tree-sitter-tablegen">LLVM TableGen</a></li>
<li><a href="https://github.com/MunifTanjim/tree-sitter-lua">Lua</a></li>
<li><a href="https://github.com/krn-robin/tree-sitter-magik">Magik</a></li>
<li><a href="https://github.com/alemuller/tree-sitter-make">Make</a></li>
<li><a href="https://github.com/ikatyang/tree-sitter-markdown">Markdown</a></li>
<li><a href="https://github.com/MDeiml/tree-sitter-markdown">Markdown</a></li>
<li><a href="https://github.com/Decodetalkers/tree-sitter-meson">Meson</a></li>
<li><a href="https://github.com/staysail/tree-sitter-meson">Meson</a></li>
<li><a href="https://github.com/grahambates/tree-sitter-m68k">Motorola 68000 assembly</a></li>
<li><a href="https://github.com/alaviss/tree-sitter-nim">Nim</a></li>
<li><a href="https://github.com/cstrahan/tree-sitter-nix">Nix</a></li>
<li><a href="https://github.com/hhamud/tree-sitter-noir">Noir</a></li>
<li><a href="https://github.com/jiyee/tree-sitter-objc">Objective-C</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-ocaml">OCaml</a></li>
<li><a href="https://github.com/amaanq/tree-sitter-odin">Odin</a></li>
<li><a href="https://github.com/novusnota/tree-sitter-ohm">Ohm</a></li>
<li><a href="https://github.com/milisims/tree-sitter-org">Org</a></li>
<li><a href="https://github.com/ace-design/tree-sitter-p4">P4</a></li>
<li><a href="https://github.com/Isopod/tree-sitter-pascal">Pascal</a></li>
<li><a href="https://github.com/ganezdragon/tree-sitter-perl">Perl</a></li>
<li><a href="https://github.com/tree-sitter-perl/tree-sitter-perl">Perl</a></li>
<li><a href="https://github.com/tree-sitter-perl/tree-sitter-pod">Perl POD</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-php">PHP</a></li>
<li><a href="https://github.com/rolandwalker/tree-sitter-pgn">Portable Game Notation</a></li>
<li><a href="https://github.com/airbus-cert/tree-sitter-powershell">PowerShell</a></li>
<li><a href="https://github.com/mitchellh/tree-sitter-proto">Protocol Buffers</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-python">Python</a></li>
<li><a href="https://github.com/yuja/tree-sitter-qmljs">QML</a></li>
<li><a href="https://github.com/vkazanov/tree-sitter-quakec">QuakeC</a></li>
<li><a href="https://github.com/6cdh/tree-sitter-racket">Racket</a></li>
<li><a href="https://github.com/Fymyte/tree-sitter-rasi">Rasi</a></li>
<li><a href="https://github.com/alemuller/tree-sitter-re2c">re2c</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-regex">Regex</a></li>
<li><a href="https://github.com/FallenAngel97/tree-sitter-rego">Rego</a></li>
<li><a href="https://github.com/stsewd/tree-sitter-rst">reStructuredText</a></li>
<li><a href="https://github.com/r-lib/tree-sitter-r">R</a></li>
<li><a href="https://github.com/Hubro/tree-sitter-robot">Robot</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-ruby">Ruby</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-rust">Rust</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-scala">Scala</a></li>
<li><a href="https://github.com/6cdh/tree-sitter-scheme">Scheme</a></li>
<li><a href="https://github.com/serenadeai/tree-sitter-scss">SCSS</a></li>
<li><a href="https://github.com/AbstractMachinesLab/tree-sitter-sexp">S-expressions</a></li>
<li><a href="https://github.com/amaanq/tree-sitter-smali">Smali</a></li>
<li><a href="https://git.sr.ht/%7Eyotam/tree-sitter-smali">Smali</a></li>
<li><a href="https://github.com/nilshelmig/tree-sitter-sourcepawn">SourcePawn</a></li>
<li><a href="https://github.com/BonaBeavis/tree-sitter-sparql">SPARQL</a></li>
<li><a href="https://github.com/takegue/tree-sitter-sql-bigquery">SQL - BigQuery</a></li>
<li><a href="https://github.com/DerekStride/tree-sitter-sql">SQL - General</a></li>
<li><a href="https://github.com/m-novikov/tree-sitter-sql">SQL - PostgreSQL</a></li>
<li><a href="https://github.com/dhcmrlchtdj/tree-sitter-sqlite">SQL - SQLite</a></li>
<li><a href="https://github.com/metio/tree-sitter-ssh-client-config">SSH</a></li>
<li><a href="https://github.com/madskjeldgaard/tree-sitter-supercollider">Supercollider</a></li>
<li><a href="https://github.com/Himujjal/tree-sitter-svelte">Svelte</a></li>
<li><a href="https://github.com/alex-pinkus/tree-sitter-swift">Swift</a></li>
<li><a href="https://github.com/SystemRDL/tree-sitter-systemrdl">SystemRDL</a></li>
<li><a href="https://github.com/tact-lang/tree-sitter-tact">Tact</a></li>
<li><a href="https://github.com/duskmoon314/tree-sitter-thrift">Thrift</a></li>
<li><a href="https://github.com/stsewd/tree-sitter-comment">&quot;TODO:&quot; comments</a></li>
<li><a href="https://github.com/ikatyang/tree-sitter-toml">TOML</a></li>
<li><a href="https://github.com/nvim-treesitter/tree-sitter-query">Tree-sitter Query</a></li>
<li><a href="https://github.com/BonaBeavis/tree-sitter-turtle">Turtle</a></li>
<li><a href="https://github.com/kaermorchen/tree-sitter-twig">Twig</a></li>
<li><a href="https://github.com/gbprod/tree-sitter-twig">Twig</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-typescript">TypeScript</a></li>
<li><a href="https://github.com/Philipp-M/tree-sitter-ungrammar">Ungrammar</a></li>
<li><a href="https://github.com/ColinKennedy/tree-sitter-usd">USD</a></li>
<li><a href="https://github.com/tree-sitter/tree-sitter-verilog">Verilog</a></li>
<li><a href="https://github.com/alemuller/tree-sitter-vhdl">VHDL</a></li>
<li><a href="https://github.com/ikatyang/tree-sitter-vue">Vue</a></li>
<li><a href="https://github.com/wasm-lsp/tree-sitter-wasm">Wasm</a></li>
<li><a href="https://github.com/jdidion/tree-sitter-wdl">WDL</a></li>
<li><a href="https://github.com/mehmetoguzderin/tree-sitter-wgsl">WGSL (WebGPU Shading Language)</a></li>
<li><a href="https://github.com/ikatyang/tree-sitter-yaml">YAML</a></li>
<li><a href="https://github.com/Hubro/tree-sitter-yang">YANG</a></li>
<li><a href="https://github.com/Philipp-M/tree-sitter-yuck">Yuck</a></li>
<li><a href="https://github.com/maxxnino/tree-sitter-zig">Zig</a></li>
</ul>
<!-- textlint-enable -->
<h3><a class="header" href="#tree-sitterに関する講演" id="tree-sitterに関する講演">Tree-sitterに関する講演</a></h3>
<ul>
<li><a href="https://www.thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html">Strange Loop 2018</a></li>
<li><a href="https://www.youtube.com/watch?v=0CGzC_iss-8">FOSDEM 2018</a></li>
<li><a href="https://www.youtube.com/watch?v=a1rC79DHpmY">GitHub Universe 2017</a></li>
</ul>
<h3><a class="header" href="#基礎研究" id="基礎研究">基礎研究</a></h3>
<p>Tree-sitterの設計は、以下の研究論文から大きな影響を受けている。</p>
<ul>
<li><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1997/CSD-97-946.pdf">Practical Algorithms for Incremental Software Development Environments</a></li>
<li><a href="https://www-users.cse.umn.edu/%7Eevw/pubs/vanwyk07gpce/vanwyk07gpce.pdf">Context Aware Scanning for Parsing Extensible Languages</a></li>
<li><a href="http://harmonia.cs.berkeley.edu/papers/twagner-parsing.pdf">Efficient and Flexible Incremental Parsing</a></li>
<li><a href="http://harmonia.cs.berkeley.edu/papers/twagner-glr.pdf">Incremental Analysis of Real Programming Languages</a></li>
<li><a href="http://what-when-how.com/compiler-writing/bottom-up-parsing-compiler-writing-part-13">Error Detection and Recovery in LR Parsers</a></li>
<li><a href="https://apps.dtic.mil/sti/pdfs/ADA043470.pdf">Error Recovery for LR Parsers</a></li>
</ul>
<!-- textlint-disable -->
<p><a href="../README.html">目次</a> ----&gt; <a href="./section-2-using-parsers.html">次のページ(パーサを使う)</a></p>
<!-- textlint-enable --><p><a href="./index.html">前のページ(トップページ)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-3-creating-parsers.html">次のページ(パーサを作る)</a></p>
<h1><a class="header" href="#パーサを使う" id="パーサを使う">パーサを使う</a></h1>
<p>Tree-sitterのパーサ機能はすべてC言語のAPIから利用可能である。高級言語で書かれたアプリケーションは、<a href="https://github.com/tree-sitter/node-tree-sitter">node-tree-sitter</a>や<a href="https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust">tree-sitter rust crate</a>のようなバインディングライブラリを介してTree-sitterを利用できる。また、これらには独自のドキュメントが存在する。</p>
<p>この文書では、使用している言語に関係なく関連する、Tree-sitterの使用方法に関する一般的な概念について説明する。また、C言語APIを直接使用している場合や、異なる言語への新しいバインディングを構築している場合に役立つ、C言語固有の詳細についても説明する。</p>
<p>ここで紹介するAPI関数は、<a href="https://github.com/tree-sitter/tree-sitter/blob/master/lib/include/tree_sitter/api.h"><code>tree_sitter/api.h</code></a>で宣言され、文書化されている。また、C言語APIと密接に対応する<a href="https://docs.rs/tree-sitter/latest/tree_sitter/">Rust APIドキュメント</a>を参照するとよい。</p>
<h2><a class="header" href="#はじめに" id="はじめに">はじめに</a></h2>
<h3><a class="header" href="#ライブラリのビルド" id="ライブラリのビルド">ライブラリのビルド</a></h3>
<p>POSIXシステム上でライブラリをビルドするには、Tree-sitterディレクトリで<code>make</code>を実行するだけである。これにより、動的ライブラリの他に、<code>libtree-sitter.a</code>という静的ライブラリが作成される。</p>
<p>また、大規模なプロジェクトのビルドシステムにこのライブラリを組み込むには、下記のソースファイルを追加する。このソースファイルをコンパイルするには、インクルードパスに下記の2つのディレクトリを追加する必要がある。</p>
<p><strong>ソースファイル:</strong></p>
<ul>
<li><code>tree-sitter/lib/src/lib.c</code></li>
</ul>
<p><strong>インクルードディレクトリ:</strong></p>
<ul>
<li><code>tree-sitter/lib/src</code></li>
<li><code>tree-sitter/lib/include</code></li>
</ul>
<h3><a class="header" href="#基本オブジェクト" id="基本オブジェクト">基本オブジェクト</a></h3>
<p>Tree-sitterを使用する際には、言語・パーサ・構文木・構文ノードに対応する4種類のオブジェクトを利用する。C言語APIでは、これらを<code>TSLanguage</code>・<code>TSParser</code>・<code>TSTree</code>・<code>TSNode</code>として定義する。</p>
<ul>
<li><code>TSLanguage</code>は、解析対象のプログラミング言語をどのようにパースするかを定義するオブジェクトである。各<code>TSLanguage</code>のコードは、Tree-sitterによって生成される。多くの言語は、<a href="https://github.com/tree-sitter">Tree-sitterのGitHub Organization</a>の個別のGitリポジトリから利用可能である。新しい言語のパーサを作成するには<a href="./section-3-creating-parsers.html">次のページ</a>を参照せよ。</li>
<li><code>TSParser</code>は、<code>TSLanguage</code>を割り当てられ、あるソースコードに基づいてTSTreeを生成するために使用できるステートフルなオブジェクトである。</li>
<li><code>TSTree</code>は、ソースコード全体の構文木を表す。この構文木は、ソースコードの構造を示す<code>TSNode</code>インスタンスを含む。またソースコードが変更時に、<code>TSTree</code>を編集することで新しい<code>TSTree</code>を生成できる。</li>
<li><code>TSNode</code>は、構文木に含まれるある1つのノードを表す。<code>TSNode</code>はソースコード内における開始位置・終了位置や親ノード・兄弟ノード・子ノードなどの他のノードとの関係に関する情報を保持する。</li>
</ul>
<h3><a class="header" href="#サンプルプログラム" id="サンプルプログラム">サンプルプログラム</a></h3>
<p>以下はTree-sitterの<a href="https://github.com/tree-sitter/tree-sitter-json">JSONパーサ</a>を利用するC言語のサンプルプログラムである。</p>
<pre><code class="language-c">// ファイル名 - test-json-parser.c

#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tree_sitter/api.h&gt;

// `tree-sitter-json`ライブラリで実装された`tree_sitter_json`関数の宣言
TSLanguage *tree_sitter_json();

int main() {
  // パーサの作成
  TSParser *parser = ts_parser_new();

  // パーサの言語(この例ではJSON)を設定する
  ts_parser_set_language(parser, tree_sitter_json());

  // ソースコードを格納した文字列から構文木を作成する
  const char *source_code = &quot;[1, null]&quot;;
  TSTree *tree = ts_parser_parse_string(
    parser,
    NULL,
    source_code,
    strlen(source_code)
  );

  // 構文木のルートノードを取得する
  TSNode root_node = ts_tree_root_node(tree);

  // 子ノードを取得をする
  TSNode array_node = ts_node_named_child(root_node, 0);
  TSNode number_node = ts_node_named_child(array_node, 0);

  // ノードが期待通りの型を持つかを検査する
  assert(strcmp(ts_node_type(root_node), &quot;document&quot;) == 0);
  assert(strcmp(ts_node_type(array_node), &quot;array&quot;) == 0);
  assert(strcmp(ts_node_type(number_node), &quot;number&quot;) == 0);

  // ノードが期待通りの数の子ノードを持つかを検査する
  assert(ts_node_child_count(root_node) == 1);
  assert(ts_node_child_count(array_node) == 5);
  assert(ts_node_named_child_count(array_node) == 2);
  assert(ts_node_child_count(number_node) == 0);

  // 構文木をS式として出力する
  char *string = ts_node_string(root_node);
  printf(&quot;Syntax tree: %s\n&quot;, string);

  // ヒープメモリに確保したデータを解放する
  free(string);
  ts_tree_delete(tree);
  ts_parser_delete(parser);
  return 0;
}
</code></pre>
<p>このプログラムは<code>tree-sitter/api.h</code>で宣言されたC言語APIを利用しているため、<code>tree-sitter/lib/include</code>をインクルードパスに追加する必要がある。
また、<code>libtree-sitter.a</code> をバイナリにリンクする必要もある。
JSONのソースコードもバイナリに直接コンパイルしている。</p>
<pre><code class="language-sh">clang                                   \
  -I tree-sitter/lib/include            \
  test-json-parser.c                    \
  tree-sitter-json/src/parser.c         \
  tree-sitter/libtree-sitter.a          \
  -o test-json-parser

./test-json-parser
</code></pre>
<h2><a class="header" href="#構文解析の基礎" id="構文解析の基礎">構文解析の基礎</a></h2>
<h3><a class="header" href="#ソースコードを引き渡す" id="ソースコードを引き渡す">ソースコードを引き渡す</a></h3>
<p>上記の例では<code>ts_parser_parse_string</code>を使って、stringに格納されたソースコードをパースした。</p>
<pre><code class="language-c">TSTree *ts_parser_parse_string(
  TSParser *self,
  const TSTree *old_tree,
  const char *string,
  uint32_t length
);
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Piece_table">piece table</a>や<a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">rope</a>等の独自のデータ構造に格納されたデータを構文解析したい場合は、<code>ts_parser_parse</code>関数を使用する。</p>
<pre><code class="language-c">TSTree *ts_parser_parse(
  TSParser *self,
  const TSTree *old_tree,
  TSInput input
);
</code></pre>
<p><code>TSInput</code>構造体を使うことで、与えられたバイトオフセットと行/列の位置でテキストのチャンクを読み取るための独自の関数を指定できる。この関数は、UTF-8またはUTF-16でエンコードされたテキストを返す。このインタフェースにより、独自のデータ構造に格納されたテキストを効率的に解析できる。</p>
<pre><code class="language-c">typedef struct {
  void *payload;
  const char *(*read)(
    void *payload,
    uint32_t byte_offset,
    TSPoint position,
    uint32_t *bytes_read
  );
  TSInputEncoding encoding;
} TSInput;
</code></pre>
<h3><a class="header" href="#構文ノード" id="構文ノード">構文ノード</a></h3>
<p>Tree-sitterは構文木を検査するために、<a href="https://ja.wikipedia.org/wiki/Document_Object_Model">DOM</a>に類似したインタフェースを提供する。構文ノードの型は、そのノードがどの文法規則を表しているかを示す文字列である。</p>
<pre><code class="language-c">const char *ts_node_type(TSNode);
</code></pre>
<p>構文ノードは、ソースコード内の位置を先頭バイトからのオフセットと行／列の両方の形式で保持する。</p>
<pre><code class="language-c">uint32_t ts_node_start_byte(TSNode);
uint32_t ts_node_end_byte(TSNode);

typedef struct {
  uint32_t row;
  uint32_t column;
} TSPoint;

TSPoint ts_node_start_point(TSNode);
TSPoint ts_node_end_point(TSNode);
</code></pre>
<h3><a class="header" href="#ノードの取得" id="ノードの取得">ノードの取得</a></h3>
<p>すべての構文木はルートノードを持つ。</p>
<pre><code class="language-c">TSNode ts_tree_root_node(const TSTree *);
</code></pre>
<p>任意のノードに対して、その子ノードにアクセスできる。</p>
<pre><code class="language-c">uint32_t ts_node_child_count(TSNode);
TSNode ts_node_child(TSNode, uint32_t);
</code></pre>
<p>兄弟ノードや親ノードにもアクセスできる。</p>
<pre><code class="language-c">TSNode ts_node_next_sibling(TSNode);
TSNode ts_node_prev_sibling(TSNode);
TSNode ts_node_parent(TSNode);
</code></pre>
<p>これらの関数はnullノードを返す場合がある。例えば、<code>ts_node_next_sibling</code>関数がnullノードを返した場合、次の兄弟ノードが存在しないことを示す。
与えられたノードがnullノードかを検査できる。</p>
<pre><code class="language-c">bool ts_node_is_null(TSNode);
</code></pre>
<h3><a class="header" href="#名前付きノードと匿名ノード" id="名前付きノードと匿名ノード">名前付きノードと匿名ノード</a></h3>
<p>Tree-sitterは<a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E6%96%87%E6%9C%A8">具象構文木</a>を生成する。具象構文木はコンマやカッコを含めたソースコードの全トークンの情報を保持する。<a href="https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%B3%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B9%E3%83%8F%E3%82%A4%E3%83%A9%E3%82%A4%E3%83%88">シンタックスハイライト</a>のように全トークンを処理する場合は、この機能は重要である。
しかし、使用用途によっては<a href="https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8">抽象構文木</a>を利用するほうが、解析が簡単である。抽象構文木とは具象構文木から重要度の低い情報を削除した木構造のデータである。
Tree-sitterの構文木は、<em>名前付きノード</em> と <em>匿名ノード</em> の2つのノードを使うことで両方の使用方法をサポートする。</p>
<p>下記のような文法定義を考える。</p>
<pre><code class="language-js">if_statement: ($) =&gt; seq(&quot;if&quot;, &quot;(&quot;, $._expression, &quot;)&quot;, $._statement);
</code></pre>
<p>この言語における<code>if_statement</code>が表す構文木は、条件式・（条件式がtrueのときに実行すべき）文・<code>if</code>・<code>(</code>・<code>)</code>の5つの子ノードを持つ。
条件式（<code>$._expression</code>）と文（<code>$._statement</code>）は、文法定義の中で明示的に名前を与えられているため <em>名前付きノード</em> である。
一方で<code>if</code>・<code>(</code>・<code>)</code>は、文法定義上は単なる文字列のため、名前付きノードではない（<em>匿名ノード</em> である）。</p>
<p>与えられたノードが名前付きノードであるかを検査できる。</p>
<pre><code class="language-c">bool ts_node_is_named(TSNode);
</code></pre>
<p>構文木を走査するときに、<code>_named_</code>を関数名に含む関数を使用することで、匿名ノードを読み飛ばせる。</p>
<pre><code class="language-c">TSNode ts_node_named_child(TSNode, uint32_t);
uint32_t ts_node_named_child_count(TSNode);
TSNode ts_node_next_named_sibling(TSNode);
TSNode ts_node_prev_named_sibling(TSNode);
</code></pre>
<p>これらの関数を使用することで、構文木は抽象構文木のように扱える。</p>
<h3><a class="header" href="#ノードのフィールド名" id="ノードのフィールド名">ノードのフィールド名</a></h3>
<!-- textlint-disable -->
<p>構文木の解析を容易にするために、多くの文法定義では一意な <em>フィールド名</em> を一部の子ノードに付与する。</p>
<!-- textlint-enable -->
<p>フィールドが存在する場合、フィールド名を介して子ノードにアクセスできる。</p>
<pre><code class="language-c">TSNode ts_node_child_by_field_name(
  TSNode self,
  const char *field_name,
  uint32_t field_name_length
);
</code></pre>
<p>フィールドは数値のIDも持っており、文字列の比較を繰り返したくない場合に利用できる。文字列とIDの変換には <code>TSLanguage</code> を使用できる。</p>
<pre><code class="language-c">uint32_t ts_language_field_count(const TSLanguage *);
const char *ts_language_field_name_for_id(const TSLanguage *, TSFieldId);
TSFieldId ts_language_field_id_for_name(const TSLanguage *, const char *, uint32_t);
</code></pre>
<p>フィールドIDはフィールド名の代わりに使用できる。</p>
<pre><code class="language-c">TSNode ts_node_child_by_field_id(TSNode, TSFieldId);
</code></pre>
<h2><a class="header" href="#応用的な構文解析" id="応用的な構文解析">応用的な構文解析</a></h2>
<h3><a class="header" href="#編集" id="編集">編集</a></h3>
<p>テキストエディタのようなアプリケーションでは、ソースコードが変更されたら再度ソースコードを構文解析する必要がある。Tree-sitterはこのようなユースケースにも対応できるように設計されている。まず最初に、構文木を編集し、ノードの範囲を調整し、ソースコードと同期させる必要がある。</p>
<pre><code class="language-c">typedef struct {
  uint32_t start_byte;
  uint32_t old_end_byte;
  uint32_t new_end_byte;
  TSPoint start_point;
  TSPoint old_end_point;
  TSPoint new_end_point;
} TSInputEdit;

void ts_tree_edit(TSTree *, const TSInputEdit *);
</code></pre>
<p>そして、古い構文木を渡して再び <code>ts_parser_parse</code> を呼び出す。これは、内部的に古い構文木と構造を共有する新しい構文木を作成しする。</p>
<p>構文木を編集すると、そのノードの位置が変化する。<code>TSTree</code>の外側に<code>TSNode</code>インスタンスを保存している場合、キャッシュされた位置を更新するために、同じ<code>TSInput</code>値を使用して、それらの位置を個別に更新する必要がある。</p>
<pre><code class="language-c">void ts_node_edit(TSNode *, const TSInputEdit *);
</code></pre>
<p>この<code>ts_node_edit</code>関数は、構文木を編集する前に<code>TSNode</code>インスタンスを取得しておき、構文木を編集した後もその特定のノードインスタンスを使用したい場合にのみ必要である。多くの場合、編集したツリーからノードを再取得したいだけのため、<code>ts_node_edit</code>関数は必要ない。</p>
<h3><a class="header" href="#複数の言語を含む言語の構文解析" id="複数の言語を含む言語の構文解析">複数の言語を含む言語の構文解析</a></h3>
<!-- textlint-disable -->
<p>1つのファイルに複数の言語が記載される場合がある。</p>
<!-- textlint-enable -->
<p>例えば<a href="https://ejs.co/">EJS</a>や<a href="https://ruby-doc.org/stdlib-2.5.1/libdoc/erb/rdoc/ERB.html">ERB</a>といったテンプレート言語では、JavascriptやRubyのような別の言語を混ぜて書くことでHTMLを生成する。</p>
<p>Tree-sitterは、ファイルの特定の範囲にあるテキストを基に構文木を作成することで、このような種類のドキュメントを扱う。</p>
<pre><code class="language-c">typedef struct {
  TSPoint start_point;
  TSPoint end_point;
  uint32_t start_byte;
  uint32_t end_byte;
} TSRange;

void ts_parser_set_included_ranges(
  TSParser *self,
  const TSRange *ranges,
  uint32_t range_count
);
</code></pre>
<p>例えば、以下のようなERBドキュメントを考える。</p>
<pre><code class="language-erb">&lt;ul&gt;
  &lt;% people.each do |person| %&gt;
    &lt;li&gt;&lt;%= person.name %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>
<p>概念的には、範囲が重複する3つの構文木（ERB構文木、Ruby構文木、HTML構文木）で表せる。
これらの構文木は次のようなコードによって生成できる。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
#include &lt;tree_sitter/api.h&gt;

// これらの関数は各リポジトリで実装されている
const TSLanguage *tree_sitter_embedded_template();
const TSLanguage *tree_sitter_html();
const TSLanguage *tree_sitter_ruby();

int main(int argc, const char **argv) {
  const char *text = argv[1];
  unsigned len = strlen(src);

  // テキスト全体をERBとして構文解析を実行する
  TSParser *parser = ts_parser_new();
  ts_parser_set_language(parser, tree_sitter_embedded_template());
  TSTree *erb_tree = ts_parser_parse_string(parser, NULL, text, len);
  TSNode erb_root_node = ts_tree_root_node(erb_tree);

  // ERB構文木において、HTMLを示す`content`ノードと挿入されたRubyを示す`code`ノードの範囲を見つける。
  TSRange html_ranges[10];
  TSRange ruby_ranges[10];
  unsigned html_range_count = 0;
  unsigned ruby_range_count = 0;
  unsigned child_count = ts_node_child_count(erb_root_node);

  for (unsigned i = 0; i &lt; child_count; i++) {
    TSNode node = ts_node_child(erb_root_node, i);
    if (strcmp(ts_node_type(node), &quot;content&quot;) == 0) {
      html_ranges[html_range_count++] = (TSRange) {
        ts_node_start_point(node),
        ts_node_end_point(node),
        ts_node_start_byte(node),
        ts_node_end_byte(node),
      };
    } else {
      TSNode code_node = ts_node_named_child(node, 0);
      ruby_ranges[ruby_range_count++] = (TSRange) {
        ts_node_start_point(code_node),
        ts_node_end_point(code_node),
        ts_node_start_byte(code_node),
        ts_node_end_byte(code_node),
      };
    }
  }

  // HTMLを解析するために、HTMLの範囲を指定する
  ts_parser_set_language(parser, tree_sitter_html());
  ts_parser_set_included_ranges(parser, html_ranges, html_range_count);
  TSTree *html_tree = ts_parser_parse_string(parser, NULL, text, len);
  TSNode html_root_node = ts_tree_root_node(html_tree);

  // Rubyを解析するために、Rubyの範囲を指定する
  ts_parser_set_language(parser, tree_sitter_ruby());
  ts_parser_set_included_ranges(parser, ruby_ranges, ruby_range_count);
  TSTree *ruby_tree = ts_parser_parse_string(parser, NULL, text, len);
  TSNode ruby_root_node = ts_tree_root_node(ruby_tree);

  // 3つの構文木すべてを出力する
  char *erb_sexp = ts_node_string(erb_root_node);
  char *html_sexp = ts_node_string(html_root_node);
  char *ruby_sexp = ts_node_string(ruby_root_node);
  printf(&quot;ERB: %s\n&quot;, erb_sexp);
  printf(&quot;HTML: %s\n&quot;, html_sexp);
  printf(&quot;Ruby: %s\n&quot;, ruby_sexp);
  return 0;
}
</code></pre>
<p>このAPIにより、言語をどのように構成するかについて、高い柔軟性を持つ。
Tree-sitterは言語間のインタラクションを媒介する責任はない。
その代わり、任意のアプリケーション固有のロジックを使って、自由にそれを行える。</p>
<h3><a class="header" href="#並行性" id="並行性">並行性</a></h3>
<p>Tree-sitterは構文木のコピーを非常に軽量に実装することで、マルチスレッド処理もサポートする。</p>
<pre><code class="language-c">TSTree *ts_tree_copy(const TSTree *);
</code></pre>
<p>内部的には、構文木をコピーすると、原子参照カウント（原文：atomic reference count）が増加するだけである。概念的には、異なるスレッドで元の構文木を使用しながら、新しいスレッドで自由に問い合わせ、編集、解析、削除できる新しい構文木を提供するものである。
個々の<code>TSTree</code>インスタンスはスレッドセーフではないので、複数のスレッドで同時に使用したい場合は、構文木をコピーする必要があることに注意すること。</p>
<h2><a class="header" href="#構文木に対するその他の操作" id="構文木に対するその他の操作">構文木に対するその他の操作</a></h2>
<h3><a class="header" href="#カーソルを使った構文木の走査" id="カーソルを使った構文木の走査">カーソルを使った構文木の走査</a></h3>
<p><a href="section-2-using-parsers.html#retrieving-nodes">上記</a>の<code>TSNode</code> APIを使用して構文木のすべてのノードにアクセスできるが、多数のノードにアクセスする必要がある場合、カーソルを使用する方法が最も効率的である。
カーソルは、最大限の効率で構文木を走査することを可能にするステートフルなオブジェクトである。</p>
<p>任意のノードからカーソルの初期化を行える。</p>
<pre><code class="language-c">TSTreeCursor ts_tree_cursor_new(TSNode);
</code></pre>
<p>カーソルを構文木の中で移動させられる。</p>
<pre><code class="language-c">bool ts_tree_cursor_goto_first_child(TSTreeCursor *);
bool ts_tree_cursor_goto_next_sibling(TSTreeCursor *);
bool ts_tree_cursor_goto_parent(TSTreeCursor *);
</code></pre>
<p>これらの関数はカーソルの移動が成功した場合に<code>true</code>を返し、移動先のノードが存在しない場合は<code>false</code>を返す。</p>
<p>カーソルの現在のノードと、現在のノードに関連するフィールド名を常に取得できる。</p>
<pre><code class="language-c">TSNode ts_tree_cursor_current_node(const TSTreeCursor *);
const char *ts_tree_cursor_current_field_name(const TSTreeCursor *);
TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *);
</code></pre>
<h2><a class="header" href="#パターンマッチを使ったクエリ" id="パターンマッチを使ったクエリ">パターンマッチを使ったクエリ</a></h2>
<p>コード解析の多くは、構文木からパターンを探し出す作業である。
Tree-sitterは、これらのパターンを表現し、マッチングを検索するための小さな宣言型言語を提供する。
この言語はTree-sitterの<a href="./section-3-creating-parsers.html#command-test">ユニットテストシステム</a>のフォーマットと類似していする。</p>
<h3><a class="header" href="#クエリの文法" id="クエリの文法">クエリの文法</a></h3>
<p>クエリは1つ以上のパターンから構成され、各パターンは構文木における特定のノードの集合にマッチする<a href="https://ja.wikipedia.org/wiki/S%E5%BC%8F">S式</a>である。
与えられたノードにマッチする式は、ノードの型と、オプションでそのノードの子にマッチする一連のS式を含む2つの括弧で構成される。
たとえば、このパターンは、子ノードが両方とも<code>number_literal</code>ノードである<code>binary_expression</code>ノードにマッチする。</p>
<pre><code class="language-scheme">(binary_expression (number_literal) (number_literal))
</code></pre>
<p>子ノードは省略できる。
例えば、以下のクエリは<code>string_literal</code>の子ノードとして少なくとも1つ含むような<code>binary_expression</code>にマッチする。</p>
<pre><code class="language-scheme">(binary_expression (string_literal))
</code></pre>
<h4><a class="header" href="#フィールド" id="フィールド">フィールド</a></h4>
<p>一般に、子ノードに関連する<a href="section-2-using-parsers.html#node-field-names">フィールド名</a>を指定して、パターンをより具体的に指定するのがよい。
これは、子パターンの前にフィールド名を付け、その後にコロンを付けることで実現する。
例えば、下記のパターンは、フィールド名<code>object</code>の子ノード<code>call_expression</code>とフィールド名<code>left</code>の子ノード<code>member_expression</code>を持つ<code>assignment_expression</code>ノードにマッチする。</p>
<pre><code class="language-scheme">(assignment_expression
  left: (member_expression
    object: (call_expression)))
</code></pre>
<h4><a class="header" href="#フィールド条件の反転" id="フィールド条件の反転">フィールド条件の反転</a></h4>
<p>指定したフィールドを <em>持たない</em> ようなパターンを構成できる。
これを実現するには、フィールド名の直前に<code>!</code>を付与すれば良い。
例えば、下記のパターンは型パラメータを含まないクラス宣言にマッチする。</p>
<pre><code class="language-scheme">(class_declaration
  name: (identifier) @class_name
  !type_parameters)
</code></pre>
<h4><a class="header" href="#匿名ノード" id="匿名ノード">匿名ノード</a></h4>
<p>ノードを記述するための括弧付きの構文は、<a href="section-2-using-parsers.html#named-vs-anonymous-nodes">名前付きノード</a>にのみ適用される。
特定の匿名ノードにマッチさせるには、その名前を&quot;&quot;で囲んで記述する。
例えば、下記のパターンは演算子が<code>!=</code>で右辺が<code>null</code>であるような<code>binary_expression</code>にマッチする。</p>
<pre><code class="language-scheme">(binary_expression
  operator: &quot;!=&quot;
  right: (null))
</code></pre>
<h4><a class="header" href="#ノードをキャプチャする" id="ノードをキャプチャする">ノードをキャプチャする</a></h4>
<p>パターンにマッチするノードを見つけたら、そのノードの中の特定のノードに対して処理を行う場合がある。
また、パターンマッチングを行う際、パターン内の特定のノードを処理したい場合もある。
キャプチャを使うと、パターン内の特定のノードに名前を割り当てることができ、後でその名前でノードを参照できる。
キャプチャの名前は、参照するノードの後に書かれ、<code>@</code>文字で始まる。</p>
<p>たとえば、下記のパターンは識別子への関数の割り当てにマッチし、関数名<code>the-function-name</code>という名前を識別子に割り当てる。</p>
<pre><code class="language-scheme">(assignment_expression
  left: (identifier) @the-function-name
  right: (function))
</code></pre>
<p>下記のパターンはメソッド定義にマッチし、<code>the-method-name</code>をメソッド名に割り当て、<code>the-class-name</code>をクラス名に割り当てる。</p>
<pre><code class="language-scheme">(class_declaration
  name: (identifier) @the-class-name
  body: (class_body
    (method_definition
      name: (property_identifier) @the-method-name)))
</code></pre>
<h4><a class="header" href="#量化演算子" id="量化演算子">量化演算子</a></h4>
<p>後置修飾子<code>+</code>および<code>*</code>繰り返し演算子は、<a href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E6%A6%82%E5%BF%B5">正規表現</a>における<code>+</code>および<code>*</code>演算子と同様に機能する。
演算子はパターンの1回以上の繰り返しにマッチし、*演算子は0回以上の繰り返しにマッチする。</p>
<p>例えば、下記のパターンは、1つ以上のコメントの並びにマッチする。</p>
<pre><code class="language-scheme">(comment)+
</code></pre>
<p>下記のパターンはクラス宣言にマッチし、デコレータがあればすべてキャプチャする。</p>
<pre><code class="language-scheme">(class_declaration
  (decorator)* @the-decorator
  name: (identifier) @the-name)
</code></pre>
<p>また、<code>?</code>演算子を使うと、ノードをオプションとしてマークする。
例えば、このパターンはすべての関数呼び出しにマッチし、文字列引数が存在する場合はそれをキャプチャする。</p>
<pre><code class="language-scheme">(call_expression
  function: (identifier) @the-function
  arguments: (arguments (string)? @the-string-arg))
</code></pre>
<h4><a class="header" href="#グループ化" id="グループ化">グループ化</a></h4>
<p>カッコを使うことでノードの並びを1つのグループにできる。
例えば、下記のパターンはコメントと関数宣言の並びにマッチする。</p>
<pre><code class="language-scheme">(
  (comment)
  (function_declaration)
)
</code></pre>
<p><code>+</code>・<code>*</code>・<code>?</code>といった量化演算子をグループ内で利用できる。
例えば、このパターンはコンマ区切りの数字の並びにマッチする。</p>
<pre><code class="language-scheme">(
  (number)
  (&quot;,&quot; (number))*
)
</code></pre>
<h4><a class="header" href="#選言" id="選言">選言</a></h4>
<p><code>[]</code>により選言を記述できる。
これは正規表現における <em>文字クラス</em> に類似する。（<code>[abc]</code>はa,b,cのいずれかにマッチする）</p>
<p>例えばこのパターンは、変数またはオブジェクトのプロパティのいずれかの呼び出すにマッチする。
変数にマッチする場合は、<code>@function</code>としてキャプチャし、プロパティの場合は<code>@method</code>としてキャプチャする。</p>
<pre><code class="language-scheme">(call_expression
  function: [
    (identifier) @function
    (member_expression
      property: (property_identifier) @method)
  ])
</code></pre>
<p>下記のパターンはキーワードにマッチし、<code>@keyword</code>としてキャプチャする。</p>
<pre><code class="language-scheme">[
  &quot;break&quot;
  &quot;delete&quot;
  &quot;else&quot;
  &quot;for&quot;
  &quot;function&quot;
  &quot;if&quot;
  &quot;return&quot;
  &quot;try&quot;
  &quot;while&quot;
] @keyword
</code></pre>
<h4><a class="header" href="#ワイルドカード" id="ワイルドカード">ワイルドカード</a></h4>
<p><code>_</code>はワイルドカードであり、任意のノードにマッチする。
これは正規表現の<code>.</code>に類似する。
<code>(_)</code>は任意の名前付きノードにマッチし、<code>_</code>は任意の名前付きノードと匿名ノードのいずれにもマッチする。</p>
<p>例えば、下記はcall内の任意のノードにマッチする。</p>
<pre><code class="language-scheme">(call (_) @call.inner)
</code></pre>
<h4><a class="header" href="#アンカー" id="アンカー">アンカー</a></h4>
<p>アンカー演算子 <code>.</code> は、子パターンのマッチング方法を制限するために使われる。
<code>.</code>はクエリ内の位置によって動作が変わる。</p>
<p><code>.</code>がパターン内の先頭の子ノードより前に位置する場合、そのノードは親ノードの先頭の名前付き子ノードにのみマッチする。
例えば、下記のパターンは<code>array</code> ノードにマッチし、 <code>@the-element</code>キャプチャを親 <code>array</code> の最初の<code>identifier</code>ノードに代入しする。</p>
<pre><code class="language-scheme">(array . (identifier) @the-element)
</code></pre>
<p>このアンカーがないとき、上記のパターンは<code>array</code>の各<code>identifier</code>にマッチし、それぞれのマッチは<code>@the-element</code>としてキャプチャされる。
同様に、<code>.</code>がパターン内の最後尾の子ノードより後ろに位置する場合、そのノードは親ノードの最後尾の名前付き子ノードにのみマッチする。
下記のパターンは<code>block</code>内の最後の名前付き子ノードにのみマッチする例である。</p>
<pre><code class="language-scheme">(block (_) @last-expression .)
</code></pre>
<p>最後に、2つの子パターンの間にアンカーを置くと、パターンが直接の兄弟関係にあるノードにのみマッチする。
下記のパターンは、<code>a.b.c.d</code>のような長いドット付きの名前が与えられた場合、連続した識別子である <code>a, b</code>, <code>b, c</code>, <code>c, d</code> の組にのみマッチする例である。</p>
<pre><code class="language-scheme">(dotted_name
  (identifier) @prev-id
  .
  (identifier) @next-id)
</code></pre>
<p>アンカーがない場合、<code>a, c</code>や<code>b, d</code>といった組み合わせにもマッチする。</p>
<p>アンカー演算子がパターンに加える制限は、匿名ノードを無視する。</p>
<h4><a class="header" href="#述語" id="述語">述語</a></h4>
<p>パターン内の任意の場所に <em>述語</em> S式を追加することによって、パターンに関連する任意のメタデータや条件を指定できる。
述語S式は<code>#述語名</code>で始まるS式である。
<code>#述語名</code>の後、任意の数の <code>@</code> を接頭辞に持つキャプチャ名や文字列を記述して良い。</p>
<p>例えば、下記のパターンは<a href="https://en.wikipedia.org/?title=SCREAMING_SNAKE_CASE&amp;redirect=no"><code>SCREAMING_SNAKE_CASE</code></a>の識別子にマッチする。</p>
<pre><code class="language-scheme">(
  (identifier) @constant
  (#match? @constant &quot;^[A-Z][A-Z_]+&quot;)
)
</code></pre>
<p>下記のパターンはキーと値が同じkey-valueのペアにマッチする。</p>
<pre><code class="language-scheme">(
  (pair
    key: (property_identifier) @key-name
    value: (identifier) @value-name)
  (#eq? @key-name @value-name)
)
</code></pre>
<p><em>注意</em> - 述語はTree-sitter Cライブラリでは直接扱えない。上位のコードがフィルタリングを実行できるように、構造化された形で公開されるだけである。しかし、<a href="https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_rust">Rustクレート</a>や<a href="https://github.com/tree-sitter/tree-sitter/tree/master/lib/binding_web">WebAssemblyバインディング</a>のようなTree-sitterの上位バインディングでは、<code>#eq?</code>や<code>#match?</code>のようないくつかの共通の述語を実装している。</p>
<h3><a class="header" href="#クエリapi" id="クエリapi">クエリAPI</a></h3>
<p>1つ以上のパターンを含む文字列をクエリとして作成する。</p>
<pre><code class="language-c">TSQuery *ts_query_new(
  const TSLanguage *language,
  const char *source,
  uint32_t source_len,
  uint32_t *error_offset,
  TSQueryError *error_type
);
</code></pre>
<p>クエリにエラーがある場合は、<code>error_offset</code> 引数にエラーのバイトオフセットを設定し、<code>error_type</code> 引数にエラーの種類を示す値を設定する。</p>
<pre><code class="language-c">typedef enum {
  TSQueryErrorNone = 0,
  TSQueryErrorSyntax,
  TSQueryErrorNodeType,
  TSQueryErrorField,
  TSQueryErrorCapture,
} TSQueryError;
</code></pre>
<p><code>TSQuery</code>の値は不変であるため、スレッド間で安全に共有できる。
クエリを実行するには、クエリ処理のための状態を保持する<code>TSQueryCursor</code>を作成する。
クエリカーソルはスレッド間で共有すべきでないが、クエリの繰り返し実行のために再利用できる。</p>
<pre><code class="language-c">TSQueryCursor *ts_query_cursor_new(void);
</code></pre>
<p>構文木のノードを指定してクエリを実行できる。</p>
<pre><code class="language-c">void ts_query_cursor_exec(TSQueryCursor *, const TSQuery *, TSNode);
</code></pre>
<p>そのマッチを繰り返し処理できる。</p>
<pre><code class="language-c">typedef struct {
  TSNode node;
  uint32_t index;
} TSQueryCapture;

typedef struct {
  uint32_t id;
  uint16_t pattern_index;
  uint16_t capture_count;
  const TSQueryCapture *captures;
} TSQueryMatch;

bool ts_query_cursor_next_match(TSQueryCursor *, TSQueryMatch *match);
</code></pre>
<p>この関数はマッチが存在しない場合は<code>false</code>を返す。そうでない場合は、どのパターンにマッチし、どのノードがキャプチャされたかという情報を <code>match</code> に格納する。</p>
<h2><a class="header" href="#静的なノードの型" id="静的なノードの型">静的なノードの型</a></h2>
<!-- textlint-disable -->
<p>静的型付けを行う言語では、構文木が個々の構文ノードに関する特定の型情報を提供することが有益な場合がある。</p>
<!-- textlint-enable -->
<p>Tree-sitterでは、この情報を <code>node-types.json</code> という生成されたファイルを通して利用できるようにする。この <em>ノード型ファイル</em> は、文法中のすべての可能な構文ノードに関する構造化されたデータを提供する。</p>
<p>このデータを使って、静的型付けされたプログラミング言語の型宣言を生成できる。
例えば、GitHubの<a href="https://github.com/github/semantic">Semantic</a>はこれらのノード型ファイルを使って、可能なすべての構文ノードに対して<a href="https://github.com/github/semantic/tree/main/semantic-ast">Haskellデータ型を生成</a>し、コード解析アルゴリズムがHaskell型システムによって構造的に検証されることを可能にしている。</p>
<p>ノード型ファイルにはオブジェクトの配列が含まれており、各オブジェクトは以下の項目を使用して特定の型の構文ノードを記述する。</p>
<h4><a class="header" href="#基本情報" id="基本情報">基本情報</a></h4>
<p>この配列中の各オブジェクトは下記の2つのエントリを持つ。</p>
<ul>
<li><code>&quot;type&quot;</code> - どの文法規則を表すかを示す文字列。これは<a href="section-2-using-parsers.html#syntax-nodes">前述</a>の<code>ts_node_type</code>関数に相当する。</li>
<li><code>&quot;named&quot;</code> - この種のノードが、文法中のルール名に対応するか、それとも単なる文字列リテラルに対応するかを示すブール値。詳細は<a href="section-2-using-parsers.html#named-vs-anonymous-nodes">ここ</a>を参照すること。</li>
</ul>
<!-- textlint-disable -->
<p>例</p>
<!-- textlint-enable -->
<pre><code class="language-json">{
  &quot;type&quot;: &quot;string_literal&quot;,
  &quot;named&quot;: true
}
{
  &quot;type&quot;: &quot;+&quot;,
  &quot;named&quot;: false
}
</code></pre>
<p>これら2つのフィールドは、合わせてノードタイプの一意な識別子を構成する。
<code>node-types.json</code> 内の2つのトップレベルオブジェクトは、 <code>&quot;type&quot;</code>と<code>&quot;named&quot;</code>の両方が同じ値であるべきではない。</p>
<h4><a class="header" href="#内部ノード" id="内部ノード">内部ノード</a></h4>
<p>多くの構文ノードは子ノードを持つ。
ノードの型オブジェクトは、ノードが持つことのできる子ノードを以下の項目で記述する。</p>
<ul>
<li><code>&quot;fields&quot;</code> - ノードが持つことのできる<a href="section-2-using-parsers.html#node-field-names">フィールド</a>を記述したオブジェクト。このオブジェクトのキーはフィールド名で、値は以下に説明する子ノードの型オブジェクトである。</li>
<li><code>&quot;children&quot;</code> - フィールドを持たない、ノードの可能な名前の付いた子ノードをすべて記述した、子ノードの型オブジェクト。</li>
</ul>
<p>子ノードの型オブジェクトは、以下の項目を使用して子ノードの集合を記述する。</p>
<ul>
<li><code>&quot;required&quot;</code> - この集合に少なくとも1つのノードが常に存在するかどうかを示す真偽値。</li>
<li><code>&quot;multiple&quot;</code> - この集合に複数のノードが存在できるかどうかを示す真偽値。</li>
<li><code>&quot;types&quot;</code>- この集合に含まれるノードの可能なタイプを表すオブジェクトの配列。各オブジェクトは2つのキーを持つ。
その意味は前述した通りである。</li>
</ul>
<!-- textlint-disable -->
<p>例</p>
<!-- textlint-enable -->
<pre><code class="language-json">{
  &quot;type&quot;: &quot;method_definition&quot;,
  &quot;named&quot;: true,
  &quot;fields&quot;: {
    &quot;body&quot;: {
      &quot;multiple&quot;: false,
      &quot;required&quot;: true,
      &quot;types&quot;: [{ &quot;type&quot;: &quot;statement_block&quot;, &quot;named&quot;: true }]
    },
    &quot;decorator&quot;: {
      &quot;multiple&quot;: true,
      &quot;required&quot;: false,
      &quot;types&quot;: [{ &quot;type&quot;: &quot;decorator&quot;, &quot;named&quot;: true }]
    },
    &quot;name&quot;: {
      &quot;multiple&quot;: false,
      &quot;required&quot;: true,
      &quot;types&quot;: [
        { &quot;type&quot;: &quot;computed_property_name&quot;, &quot;named&quot;: true },
        { &quot;type&quot;: &quot;property_identifier&quot;, &quot;named&quot;: true }
      ]
    },
    &quot;parameters&quot;: {
      &quot;multiple&quot;: false,
      &quot;required&quot;: true,
      &quot;types&quot;: [{ &quot;type&quot;: &quot;formal_parameters&quot;, &quot;named&quot;: true }]
    }
  }
}
</code></pre>
<!-- textlint-disable -->
<p>例</p>
<!-- textlint-enable -->
<pre><code class="language-json">{
  &quot;type&quot;: &quot;array&quot;,
  &quot;named&quot;: true,
  &quot;fields&quot;: {},
  &quot;children&quot;: {
    &quot;multiple&quot;: true,
    &quot;required&quot;: false,
    &quot;types&quot;: [
      { &quot;type&quot;: &quot;_expression&quot;, &quot;named&quot;: true },
      { &quot;type&quot;: &quot;spread_element&quot;, &quot;named&quot;: true }
    ]
  }
}
</code></pre>
<h4><a class="header" href="#スーパータイプノード" id="スーパータイプノード">スーパータイプ・ノード</a></h4>
<p>Tree-sitterの文法では、通常、構文ノードの抽象的なカテゴリを表す特定のルールがある（例えば、「式」、「型」、「宣言」等）。
<code>grammar.js</code>では、これらのルールは<a href="./section-3-creating-parsers#hiding-rules">隠しルール</a>として記述され、
その定義は各メンバーが1つのシンボルである単純な<a href="./section-3-creating-parsers#the-grammar-dsl">選択</a>である場合が多い。</p>
<p>通常、隠れルールは構文ツリーには現れないので、ノードタイプファイルには記述されない。
しかし、文法の<a href="./section-3-creating-parsers#the-grammar-dsl">スーパータイプのリスト</a>に隠しルールを追加すると、ノード型ファイルに次のような特別な項目とともに表示されるようになる。</p>
<ul>
<li><code>&quot;subtypes&quot;</code> - この 'supertype' ノードがラップできるノードの型を指定するオブジェクトの配列。</li>
</ul>
<!-- textlint-disable -->
<p>例</p>
<!-- textlint-enable -->
<pre><code class="language-json">{
  &quot;type&quot;: &quot;_declaration&quot;,
  &quot;named&quot;: true,
  &quot;subtypes&quot;: [
    { &quot;type&quot;: &quot;class_declaration&quot;, &quot;named&quot;: true },
    { &quot;type&quot;: &quot;function_declaration&quot;, &quot;named&quot;: true },
    { &quot;type&quot;: &quot;generator_function_declaration&quot;, &quot;named&quot;: true },
    { &quot;type&quot;: &quot;lexical_declaration&quot;, &quot;named&quot;: true },
    { &quot;type&quot;: &quot;variable_declaration&quot;, &quot;named&quot;: true }
  ]
}
</code></pre>
<p>スーパータイプ・ノードは、ノードタイプ・ファイル内の他の場所でも、文法でスーパータイプ・ルールがどのように使われたかに対応する形で、他のノードタイプの子として表示される。これは、1つのスーパータイプが複数のサブタイプの代わりとなるため、ノードタイプをより短く、読みやすくできる。</p>
<!-- textlint-disable -->
<p>例</p>
<!-- textlint-enable -->
<pre><code class="language-json">{
  &quot;type&quot;: &quot;export_statement&quot;,
  &quot;named&quot;: true,
  &quot;fields&quot;: {
    &quot;declaration&quot;: {
      &quot;multiple&quot;: false,
      &quot;required&quot;: false,
      &quot;types&quot;: [{ &quot;type&quot;: &quot;_declaration&quot;, &quot;named&quot;: true }]
    },
    &quot;source&quot;: {
      &quot;multiple&quot;: false,
      &quot;required&quot;: false,
      &quot;types&quot;: [{ &quot;type&quot;: &quot;string&quot;, &quot;named&quot;: true }]
    }
  }
}
</code></pre>
<p><a href="./index.html">前のページ(トップページ)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-3-creating-parsers.html">次のページ(パーサを作る)</a></p>
<p><a href="./section-2-using-parsers.html">前のページ(パーサを使う)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-4-syntax-highlighting.html">次のページ(シンタックスハイライター)</a></p>
<h1><a class="header" href="#パーサを作る" id="パーサを作る">パーサを作る</a></h1>
<p>Tree-sitterによるパーサの開発は学習が難しいものの、一度コツをつかめば楽しく、禅のような感覚さえ覚えるだろう。
このドキュメントは、開発を始め方を示し、開発を進める上での考え方を身につける一助となるだろう。</p>
<h2><a class="header" href="#はじめに-1" id="はじめに-1">はじめに</a></h2>
<h3><a class="header" href="#依存するソフトウェア" id="依存するソフトウェア">依存するソフトウェア</a></h3>
<p>Tree-sitterパーサを開発するためには、いくつかのソフトウェアをインストールする必要がある。</p>
<ul>
<li><strong>Node.js</strong> - Tree-sitterの文法規則はJavaScriptで記述され、Tree-sitterはJavascript処理系として<a href="https://nodejs.org/ja/">Node.js</a>を利用する。したがって、<code>node</code>コマンドの存在するディレクトリを環境変数<code>PATH</code>に追加する必要がある。また、Node.jsのバージョンが6.0以上であることも必要である。</li>
<li><strong>Cコンパイラ</strong> - Tree-sitterはC言語で記述されたパーサを生成する。パーサの実行とテストを行う<code>tree-sitter parse</code>と<code>tree-sitter test</code>コマンドを使うにはC/C++コンパイラがインストールされている必要がある。Tree-sitterは各プラットフォーム規定する標準的なディレクトリからC/C++コンパイラを検索して利用する。</li>
</ul>
<h3><a class="header" href="#インストール" id="インストール">インストール</a></h3>
<p>Tree-sitterパーサを生成するには、<a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli">the <code>tree-sitter</code> CLI</a>が必要であり、複数の方法でインストールできる。</p>
<ul>
<li><code>tree-sitter-cli</code> <a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli">Rustクレート</a> をRustパッケージマネージャである<a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>cargo</code></a>を使ってソースコードからビルドする。これは任意のプラットフォームで有効なインストール方法である。詳細は<a href="./section-6-contributing.html">コントリビュート</a>を参照すること。
<code>tree-sitter-cli</code><a href="https://www.npmjs.com/package/tree-sitter-cli">Node.jsモジュール</a>をNodeパッケージマネージャの<a href="https://docs.npmjs.com/"><code>npm</code></a>を使ってインストールする。</li>
</ul>
<!-- textlint-disable -->
<p>この方法は手軽だが、pre-builtバイナリを使うため、限られたプラットフォームでのみ利用可能な方法である。</p>
<!-- textlint-enable -->
<ul>
<li>使用するプラットフォーム向けのバイナリを<a href="https://github.com/tree-sitter/tree-sitter/releases">最新のGitHubリリースページ</a>からダウンロードし、そのバイナリを格納したディレクトリのパスを環境変数<code>PATH</code>に追加する。</li>
</ul>
<h3><a class="header" href="#プロジェクトの新規作成" id="プロジェクトの新規作成">プロジェクトの新規作成</a></h3>
<!-- textlint-disable -->
<p>パーサのリポジトリ名は「tree-sitter-」後に言語名を付けたものが好ましい。</p>
<!-- textlint-enable -->
<pre><code class="language-sh">mkdir tree-sitter-${YOUR_LANGUAGE_NAME}
cd tree-sitter-${YOUR_LANGUAGE_NAME}
</code></pre>
<p><code>npm</code> コマンドを使って、プロジェクトに関する情報を格納する<code>package.json</code>を作成し、Node.jsから開発したパーサを利用できるようする。</p>
<pre><code class="language-sh"># 下記のコマンドでは、対話モードでプロジェクトに関する情報を入力する。
npm init

# 下記のコマンドにより、Nodeから開発したパーサを利用可能にするためのモジュールをインストールする。
npm install --save nan

# 下記のコマンドにより、Tree-sitter CLIをインストールする。
npm install --save-dev tree-sitter-cli
</code></pre>
<p>最後のコマンドにより、作業ディレクトリの<code>node_modules</code>ディレクトリにCLIツールをインストールする。
実行可能ファイル<code>tree-sitter</code>が<code>node_modules/.bin</code>ディレクトリに作成される。
Node.jsの慣習に従って、このフォルダを環境変数<code>PATH</code>に追加しておくと、このディレクトリで作業しているときに簡単にプログラムを実行できる。</p>
<pre><code class="language-sh"># In your shell profile script
export PATH=$PATH:./node_modules/.bin
</code></pre>
<p>CLIのインストールを完了したら、<code>grammar.js</code>に下記の内容を書き込む。</p>
<pre><code class="language-js">module.exports = grammar({
  name: 'YOUR_LANGUAGE_NAME',

  rules: {
    // TODO: add the actual grammar rules
    source_file: $ =&gt; 'hello'
  }
});
</code></pre>
<p>その後、下記のコマンドを実行する。</p>
<pre><code class="language-sh">tree-sitter generate
</code></pre>
<p>これは、この些細な言語を解析するのに必要なCコードと、このネイティブパーサーをNode.jsモジュールとしてコンパイルしてロードするために必要ないくつかのファイルを生成する。</p>
<p>下記のように「hello」と書き込まれたソースファイルを用意すれば、生成したパーサをテストできる。</p>
<pre><code class="language-sh">echo 'hello' &gt; example-file
tree-sitter parse example-file
</code></pre>
<p>WindowsのPowerShellを使う場合は下記のコマンドを実行する。</p>
<pre><code class="language-pwsh">&quot;hello&quot; | Out-File example-file -Encoding utf8
tree-sitter parse example-file
</code></pre>
<p>これにより、下記のメッセージが出力される。</p>
<pre><code>(source_file [0, 0] - [1, 0])
</code></pre>
<p>実際に動作するパーサを作成できた。</p>
<h2><a class="header" href="#tool-overview" id="tool-overview">Tool Overview</a></h2>
<p>コマンドラインツール<code>tree-sitter</code>の機能を紹介する。</p>
<h3><a class="header" href="#generateコマンド" id="generateコマンド"><code>generate</code>コマンド</a></h3>
<p>最も重要なのは<code>tree-sitter generate</code>コマンドである。
このコマンドはカレントディレクトリの<code>grammar.js</code>を読み込み、<code>src/parser.c</code>にパーサの実装を書き出す。
文法を変更したら、<code>tree-sitter generate</code>コマンドを再度実行する必要がある。</p>
<p><code>tree-sitter generate</code>を最初に実行したとき、下記のファイルも生成される。</p>
<ul>
<li><code>binding.gyp</code> -Node.jsが作成した言語をどのようにコンパイルするかが記述されるたファイル。</li>
<li><code>bindings/node/index.js</code> - 作成した言語を使用する際にNode.jsが内部で読み込むファイル。</li>
<li><code>bindings/node/binding.cc</code> - Node.jsが使用するJavaScriptオブジェクトのラッパーが記述されるたファイル。</li>
<li><code>bindings/rust/lib.rs</code> - 作成した言語をRustから利用するためのラッパーが記述されたファイル。</li>
<li><code>bindings/rust/build.rs</code> - Rustクレート向けのビルド処理が記述されるたファイル。</li>
<li><code>src/tree_sitter/parser.h</code> - 生成した<code>parser.c</code>が使用するヘッダファイル。</li>
</ul>
<p>文法に曖昧さや局所的な曖昧さ（原文：local ambiguity）がある場合、Tree-sitterはパーサの生成時にそれを検出し、
Unresolved conflictというエラーメッセージを表示して終了する。
これらのエラーの詳細については、以下を参照せよ。</p>
<h3><a class="header" href="#command-test" id="command-test">Command: <code>test</code></a></h3>
<p><code>tree-sitter test</code>コマンドを使ってパーサを簡単にテストできる。</p>
<p>新たな文法規則を追加するたびに、パースするたびに構文木がどのような形式になるかを検証するテストを作成すべきである。
これらのテストはプロジェクトルートの<code>corpus/</code>または<code>test/corpus/</code>ディレクトリ以下のテキストファイルに専用フォーマットで記述する。</p>
<p>例えば、下記の内容が書き込まれた<code>test/corpus/statements.txt</code>ファイルを考える。</p>
<pre><code>==================
Return statements
==================

func x() int {
  return 1;
}

---

(source_file
  (function_definition
    (identifier)
    (parameter_list)
    (primitive_type)
    (block
      (return_statement (number)))))
</code></pre>
<ul>
<li>
<p><code>=</code>がの間に<strong>テスト名</strong>を書く。</p>
</li>
<li>
<p>その後にパーサの<strong>入力</strong>となるソースコードを書き、3つ以上の<code>-</code>を含む行を書く。</p>
</li>
<li>
<p>その後に<strong>出力として期待される構文木</strong>を<a href="https://ja.wikipedia.org/wiki/S%E5%BC%8F"><code>S式</code></a>で書く。S式中の空白は無視されるが、理想的には構文木は読みやすい方が良い。S式は、<code>func</code>、<code>(</code>、<code>;</code>といった、分包機そうでは文字列や正規表現で表される構文ノードを表示しないことに注意せよ。構文木は、<a href="./section-2-using-parsers.html#%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E3%83%8E%E3%83%BC%E3%83%89%E3%81%A8%E5%8C%BF%E5%90%8D%E3%83%8E%E3%83%BC%E3%83%89">「パーサの使う」のこの節</a>で説明した名前付きノード*のみを表示する。</p>
<p>期待出力を示すセクションには、各子ノードに関連付けられた<a href="./using-parsers#node-field-names"><em>フィールド名</em></a>をオプションで表示できる。テストにフィールド名を含める場合、S式内のノードの前に、コロンに続いてノード自体を記述する前に、ノードのフィールド名を記述する。</p>
</li>
</ul>
<pre><code>(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    result: (primitive_type)
    body: (block
      (return_statement (number)))))
</code></pre>
<ul>
<li>もし言語の構文が<code>===</code>と<code>---</code>のテストセパレータと衝突する場合、同一のサフィックス（下記の例では<code>|||</code>）を追加して曖昧さを解消できる。</li>
</ul>
<pre><code>==================|||
Basic module
==================|||

---- MODULE Test ----
increment(n) == n + 1
====

---|||

(source_file
  (module (identifier)
    (operator (identifier)
      (parameter_list (identifier))
      (plus (identifier_ref) (number)))))
</code></pre>
<p>これらのテストは重要である。
テストはパーサのAPIドキュメントとして機能し、文法を変更するたびにすべてが正しくパースされていることを確認するために実行できる。</p>
<p>デフォルトで<code>tree-sitter test</code>コマンドは<code>corpus</code>または<code>test/corpus/</code>フォルダ内のすべてのテストを実行する。
特定のテストを実行するには、<code>-f</code>フラグを使う。</p>
<pre><code class="language-sh">tree-sitter test -f 'Return statements'
</code></pre>
<p>包括的なテストを追加することが推奨される。
もし非可視性のノードがある場合、<code>corpus</code>ディレクトリ内のテストファイルに追加することが良いだろう。
通常、各言語構造のすべての組み合わせをテストすることが良い。
これによりテストカバレッジが向上し、言語の「エッジ」を理解するための方法を読者に二重で提供できる。</p>
<!-- textlint-disable -->
<h4><a class="header" href="#自動コンパイル" id="自動コンパイル">自動コンパイル</a></h4>
<p><code>tree-sitter test</code>を実行するたびに、パーサのCコードを再コンパイルするので、最初の実行時には少し時間がかかる場合がある。
これは、Tree-sitterが自動的にCコードを動的ロード可能なライブラリにコンパイルするためである。
<code>tree-sitter generate</code>を再実行してパーサを更新するたびに、必要に応じてパーサを再コンパイルする。</p>
<h4><a class="header" href="#シンタックスハイライトのテスト" id="シンタックスハイライトのテスト">シンタックスハイライトのテスト</a></h4>
<p><code>tree-sitter test</code>コマンドは、<code>test/highlight</code>フォルダ内にシンタックスハイライトのテストが存在する場合、それらも実行する。
詳細は<a href="./syntax-highlighting#unit-testing">シンタックスハイライトのページ</a>を参照すること。</p>
<h3><a class="header" href="#parseコマンド" id="parseコマンド"><code>parse</code>コマンド</a></h3>
<p><code>tree-sitter parse</code>コマンドを使って任意のファイルをパースできる。
これにより、下記のような範囲とフィールド名を含む構文木が表示される。</p>
<pre><code>(source_file [0, 0] - [3, 0]
  (function_declaration [0, 0] - [2, 1]
    name: (identifier [0, 5] - [0, 9])
    parameters: (parameter_list [0, 9] - [0, 11])
    result: (type_identifier [0, 12] - [0, 15])
    body: (block [0, 16] - [2, 1]
      (return_statement [1, 2] - [1, 10]
        (expression_list [1, 9] - [1, 10]
          (int_literal [1, 9] - [1, 10]))))))
</code></pre>
<p><code>tree-sitter parse</code>コマンドには、任意のファイルパスとグロブパターンを渡すことができ、指定されたすべてのファイルを解析する。
パースエラーが発生した場合、コマンドはゼロ以外のステータスコードで終了する。
<code>--quiet</code>フラグを使用して、構文木の出力を抑制することもできる。
さらに、<code>--stat</code>フラグを使用すると、処理されたすべてのファイルに対する集計されたパース成功/失敗情報が出力される。
これにより、<code>tree-sitter parse</code>を二次的なテスト戦略として使用できるようになります。
つまり、多数のファイルがエラーなしでパースされることを確認できます。</p>
<pre><code class="language-sh">tree-sitter parse 'examples/**/*.go' --quiet --stat
</code></pre>
<h3><a class="header" href="#highlightコマンド" id="highlightコマンド"><code>highlight</code>コマンド</a></h3>
<p><code>tree-sitter highlight</code>コマンドを使って任意のファイルにシンタックスハイライトの処理を実行できる。
これにより、ターミナルに直接色を出力することも可能だし、<code>--html</code>フラグを渡すことでHTMLを生成することもできる。
詳細は<a href="./syntax-highlighting">シンタックスハイライトのページ</a>を参照すること。</p>
<h3><a class="header" href="#文法dsl" id="文法dsl">文法DSL</a></h3>
<p>下記は<code>grammar.js</code>で使用できる組み込み関数の一覧である。
これらの関数の使用例は、後のセクションで詳しく説明される。</p>
<ul>
<li><strong>シンボル(<code>$</code>オブジェクト)</strong> - すべての文法規則は、通常<code>$</code>と呼ばれるパラメータを取るJavaScript関数として記述される。<code>$.identifier</code>という構文は、規則内で他の文法シンボルを参照する方法である。<code>$.MISSING</code>または<code>$.UNEXPECTED</code>で始まる名前は、<code>tree-sitter test</code>コマンドに特別な意味があるため避けるべきである。</li>
<li><strong>文字列と正規表現リテラル</strong> - 文法の終端記号は、JavaScriptの文字列と正規表現を使って記述される。もちろん、パーサは実際にはJavaScriptの正規表現エンジンを使ってこれらの正規表現を評価しない。パーサは、各パーサの一部として独自の正規表現マッチングロジックを生成する。正規表現リテラルは、文法内で正規表現を書く便利な方法である。</li>
<li><strong>シーケンス: <code>seq(rule1, rule2, ...)</code></strong> - この関数は、他のルールに一つずつ順番にマッチするルールを作成する。これは<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF記法</a>で複数のシンボルを隣り合わせに書くのと同様である。</li>
<li><strong>選択: <code>choice(rule1, rule2, ...)</code></strong> - この関数は、可能なルールのセットの<em>1つ</em>にマッチするルールを作成する。引数の順序は重要ではない。これは、EBNF記法の<code>|</code>（パイプ）演算子に類似している。</li>
<li><strong>繰り返し: <code>repeat(rule)</code></strong> - この関数は、指定されたルールの<em>0個以上</em>の出現にマッチするルールを作成する。以前の<code>repeat</code>ルールは<code>repeat1</code>を使って実装されているが、非常に一般的であるため含まれている。</li>
<li>** 繰り返し1: <code>repeat1(rule)</code>** - この関数は、指定されたルールの<em>1個以上</em>の出現にマッチするルールを作成する。以前の<code>repeat</code>ルールは<code>repeat1</code>を使って実装されているが、非常に一般的であるため含まれている。</li>
<li><strong>オプション: <code>optional(rule)</code></strong> - この関数は、指定されたルールの<em>0個または1個</em>の出現にマッチするルールを作成する。これは、EBNF記法の<code>[x]</code>（角括弧）構文に類似している。</li>
<li><strong>優先: <code>prec(number, rule)</code></strong> - この関数は、指定されたルールに数値の優先度を付与し、パーサ生成時に<a href="https://en.wikipedia.org/wiki/LR_parser#Conflicts_in_the_constructed_tables"><em>LR(1)コンフリクト</em></a>を解決するために使用される。2つのルールが、1つのトークンの先読みを考慮して真の曖昧さまたは<em>局所的な</em>曖昧さを表す方法で重なる場合、Tree-sitterは、より高い優先度を持つルールをマッチングしてコンフリクトを解決しようとする。すべてのルールのデフォルトの優先度はゼロである。これは、Yacc文法の<a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html">優先度ディレクティブ</a>と同様に機能する。</li>
<li><strong>左結合 : <code>prec.left([number], rule)</code></strong> - この関数は、指定されたルールを左結合としてマークし（オプションで数値の優先度を適用）、LR(1)コンフリクトが発生した場合、すべてのルールが同じ数値の優先度を持つ場合、Tree-sitterはルールの結合性を参照する。左結合ルールがある場合、Tree-sitterは、より早く終了するルールをマッチングすることを優先する。これは、Yacc文法の<a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html">結合性ディレクティブ</a>と同様に機能する。</li>
<li><strong>右結合 : <code>prec.right([number], rule)</code></strong> - この関数は<code>prec.left</code>と同様であるが、Tree-sitterに対して後で終了するルールをマッチングすることを優先するように指示する。</li>
<li><strong>Dynamic Precedence : <code>prec.dynamic(number, rule)</code></strong> - This function is similar to <code>prec</code>, but the given numerical precedence is applied at <em>runtime</em> instead of at parser generation time. This is only necessary when handling a conflict dynamically using the <code>conflicts</code> field in the grammar, and when there is a genuine <em>ambiguity</em>: multiple rules correctly match a given piece of code. In that event, Tree-sitter compares the total dynamic precedence associated with each rule, and selects the one with the highest total. This is similar to <a href="https://www.gnu.org/software/bison/manual/html_node/Generalized-LR-Parsing.html">dynamic precedence directives</a> in Bison grammars.</li>
<li><strong>Tokens : <code>token(rule)</code></strong> - This function marks the given rule as producing only a single token. Tree-sitter's default is to treat each String or RegExp literal in the grammar as a separate token. Each token is matched separately by the lexer and returned as its own leaf node in the tree. The <code>token</code> function allows you to express a complex rule using the functions described above (rather than as a single regular expression) but still have Tree-sitter treat it as a single token.</li>
<li><strong>Immediate Tokens : <code>token.immediate(rule)</code></strong> - Usually, whitespace (and any other extras, such as comments) is optional before each token. This function means that the token will only match if there is no whitespace.</li>
<li><strong>Aliases : <code>alias(rule, name)</code></strong> - This function causes the given rule to <em>appear</em> with an alternative name in the syntax tree. If <code>name</code> is a <em>symbol</em>, as in <code>alias($.foo, $.bar)</code>, then the aliased rule will <em>appear</em> as a <a href="./using-parsers#named-vs-anonymous-nodes">named node</a> called <code>bar</code>. And if <code>name</code> is a <em>string literal</em>, as in <code>alias($.foo, 'bar')</code>, then the aliased rule will appear as an <a href="./using-parsers#named-vs-anonymous-nodes">anonymous node</a>, as if the rule had been written as the simple string.</li>
<li><strong>Field Names : <code>field(name, rule)</code></strong> - This function assigns a <em>field name</em> to the child node(s) matched by the given rule. In the resulting syntax tree, you can then use that field name to access specific children.</li>
</ul>
<p>In addition to the <code>name</code> and <code>rules</code> fields, grammars have a few other optional public fields that influence the behavior of the parser.</p>
<ul>
<li><strong><code>extras</code></strong> - an array of tokens that may appear <em>anywhere</em> in the language. This is often used for whitespace and comments. The default value of <code>extras</code> is to accept whitespace. To control whitespace explicitly, specify <code>extras: $ =&gt; []</code> in your grammar.</li>
<li><strong><code>inline</code></strong> - an array of rule names that should be automatically <em>removed</em> from the grammar by replacing all of their usages with a copy of their definition. This is useful for rules that are used in multiple places but for which you <em>don't</em> want to create syntax tree nodes at runtime.</li>
<li><strong><code>conflicts</code></strong> - an array of arrays of rule names. Each inner array represents a set of rules that's involved in an <em>LR(1) conflict</em> that is <em>intended to exist</em> in the grammar. When these conflicts occur at runtime, Tree-sitter will use the GLR algorithm to explore all of the possible interpretations. If <em>multiple</em> parses end up succeeding, Tree-sitter will pick the subtree whose corresponding rule has the highest total <em>dynamic precedence</em>.</li>
<li><strong><code>externals</code></strong> - an array of token names which can be returned by an <a href="section-3-creating-parsers.html#external-scanners"><em>external scanner</em></a>. External scanners allow you to write custom C code which runs during the lexing process in order to handle lexical rules (e.g. Python's indentation tokens) that cannot be described by regular expressions.</li>
<li><strong><code>precedences</code></strong> - an array of array of strings, where each array of strings defines named precedence levels in descending order. These names can be used in the <code>prec</code> functions to define precedence relative only to other names in the array, rather than globally. Can only be used with parse precedence, not lexical precedence.</li>
<li><strong><code>word</code></strong> - the name of a token that will match keywords for the purpose of the <a href="section-3-creating-parsers.html#keyword-extraction">keyword extraction</a> optimization.</li>
<li><strong><code>supertypes</code></strong> an array of hidden rule names which should be considered to be 'supertypes' in the generated <a href="./using-parsers#static-node-types"><em>node types</em> file</a>.</li>
</ul>
<h2><a class="header" href="#文法を記述する" id="文法を記述する">文法を記述する</a></h2>
<p>文法の記述には創造性が必要である。与えられた言語を記述するために使用できるCFG（文脈自由文法）は無限に存在する。良いTree-sitterパーサを作成するためには、2つの重要な特性を持つ文法を作成する必要がある。</p>
<ol>
<li>
<p><strong>直感的な構造</strong> - Tree-sitterの出力は<a href="https://en.wikipedia.org/wiki/Parse_tree">具象構文木</a>であり、木の各ノードは文法内の<a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols">端末記号または非端末記号</a>に直接対応している。したがって、解析しやすい木を生成するためには、文法内の記号と言語内の認識可能な構造との間に直接的な対応関係がある必要がある。これは当たり前のことのように思えるかもしれないが、<a href="https://en.wikipedia.org/wiki/Programming_language_specification">言語仕様</a>や<a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>/<a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>パーサのような文脈で文脈自由文法が書かれる方法とは非常に異なる。</p>
</li>
<li>
<p><strong>LR(1)の遵守</strong> - Tree-sitterは<a href="https://en.wikipedia.org/wiki/GLR_parser">GLRパーサ</a>アルゴリズムに基づいている。これは、任意の文脈自由文法を処理できるが、<a href="https://en.wikipedia.org/wiki/LR_parser">LR(1)文法</a>と呼ばれる文脈自由文法のクラスで最も効率的に動作する。この点で、Tree-sitterの文法は<a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>や<a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>の文法に似ているが、<a href="http://www.antlr.org/">ANTLR文法</a>、<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammars</a>、または言語仕様で一般的に使用される<a href="https://en.wikipedia.org/wiki/Ambiguous_grammar">曖昧な文法</a>とは異なる。</p>
</li>
</ol>
<p>既存の文脈自由文法を直接Tree-sitterの文法形式に変換するだけでは、これらの2つの特性を満たすことはできない可能性が高い。多くの場合、次の種類の調整が必要となる。次のセクションでは、これらの調整について詳しく説明する。</p>
<h3><a class="header" href="#まず最初に遵守すべきルール" id="まず最初に遵守すべきルール">まず最初に遵守すべきルール</a></h3>
<p>構文解析しようとする言語に対して厳密な仕様を見つけることは、通常は良いアイデアである。
この仕様には、おそらく文脈自由文法が含まれているであろう。
このCFGのルールを読み進めると、複雑で循環的な関係のグラフが見つかるかもしれない。
このグラフをナビゲートする方法が不明確になるかもしれませんが、文法を定義する際にどのように進めるべきかを理解するために、このグラフを読み進めることが重要である。</p>
<p>言語は全く違った構造を持つが、その構造はしばしば<em>宣言</em>、<em>定義</em>、<em>文</em>、<em>式</em>、<em>型</em>、<em>パターン</em>のような似たようなグループに分類されることがある。
文法を記述する際に、これらの基本的な<em>グループ</em>の記号を含むだけの構造を作成することが最初のステップとして良い。
Goのような言語の場合、次のように始めることができる。</p>
<pre><code class="language-js">{
  // ...

  rules: {
    source_file: $ =&gt; repeat($._definition),

    _definition: $ =&gt; choice(
      $.function_definition
      // TODO: other kinds of definitions
    ),

    function_definition: $ =&gt; seq(
      'func',
      $.identifier,
      $.parameter_list,
      $._type,
      $.block
    ),

    parameter_list: $ =&gt; seq(
      '(',
       // TODO: parameters
      ')'
    ),

    _type: $ =&gt; choice(
      'bool'
      // TODO: other kinds of types
    ),

    block: $ =&gt; seq(
      '{',
      repeat($._statement),
      '}'
    ),

    _statement: $ =&gt; choice(
      $.return_statement
      // TODO: other kinds of statements
    ),

    return_statement: $ =&gt; seq(
      'return',
      $._expression,
      ';'
    ),

    _expression: $ =&gt; choice(
      $.identifier,
      $.number
      // TODO: other kinds of expressions
    ),

    identifier: $ =&gt; /[a-z]+/,

    number: $ =&gt; /\d+/
  }
}
</code></pre>
<p>この文法の詳細は後に説明するが、<code>TODO</code>コメントに焦点を当てると、全体的な戦略が<em>幅優先</em>であることがわかる。
特筆すべきは、この初期のスケルトンは、言語仕様の文脈自由文法の正確なサブセットに直接マッチする必要はないということである。
単に、できるだけシンプルで明確な方法で主要なルールのグループに触れるだけでよい。</p>
<p>With this structure in place, you can now freely decide what part of the grammar to flesh out next. For example, you might decide to start with <em>types</em>. One-by-one, you could define the rules for writing basic types and composing them into more complex types:</p>
<p>この構造ができたら、次にどの部分の文法を詳細にするかを自由に決定できる。
例えば、<em>型</em>から始める場合、一つずつ基本的な型を書くためのルールを定義し、それらをより複雑な型に組み合わせることができる。</p>
<pre><code class="language-js">{
  // ...

  _type: $ =&gt; choice(
    $.primitive_type,
    $.array_type,
    $.pointer_type
  ),

  primitive_type: $ =&gt; choice(
    'bool',
    'int'
  ),

  array_type: $ =&gt; seq(
    '[',
    ']',
    $._type
  ),

  pointer_type: $ =&gt; seq(
    '*',
    $._type
  )
}
</code></pre>
<p>型のサブ言語をさらに発展させた後、<em>文</em>や<em>式</em>に取り組むことに切り替えることができる。
<code>tree-sitter parse</code>を使用して実際のコードを解析して進捗状況を確認すると良い。</p>
<p><strong>そして、<code>corpus</code>フォルダ内の各ルールに対して必ずテストを追加すること</strong></p>
<h3><a class="header" href="#ルールの適切な構造化" id="ルールの適切な構造化">ルールの適切な構造化</a></h3>
<p><a href="https://github.com/tree-sitter/tree-sitter-javascript">Tree-sitter Javascript parser</a>の作業を始めたとする。
単純に、<a href="https://262.ecma-international.org/6.0/">ECMAScript Language Spec</a>の構造を直接反映しようとするかもしれない。
このアプローチの問題を説明するために、次のコード行を考えてみる。</p>
<pre><code class="language-js">return x + y;
</code></pre>
<p>仕様によると、この行は<code>ReturnStatement</code>であり、フラグメント<code>x + y</code>は<code>AdditiveExpression</code>であり、<code>x</code>と<code>y</code>はどちらも<code>IdentifierReferences</code>である。
これらの構造の関係は、複雑な一連の生成規則によって表される。</p>
<pre><code>ReturnStatement          -&gt;  'return' Expression
Expression               -&gt;  AssignmentExpression
AssignmentExpression     -&gt;  ConditionalExpression
ConditionalExpression    -&gt;  LogicalORExpression
LogicalORExpression      -&gt;  LogicalANDExpression
LogicalANDExpression     -&gt;  BitwiseORExpression
BitwiseORExpression      -&gt;  BitwiseXORExpression
BitwiseXORExpression     -&gt;  BitwiseANDExpression
BitwiseANDExpression     -&gt;  EqualityExpression
EqualityExpression       -&gt;  RelationalExpression
RelationalExpression     -&gt;  ShiftExpression
ShiftExpression          -&gt;  AdditiveExpression
AdditiveExpression       -&gt;  MultiplicativeExpression
MultiplicativeExpression -&gt;  ExponentiationExpression
ExponentiationExpression -&gt;  UnaryExpression
UnaryExpression          -&gt;  UpdateExpression
UpdateExpression         -&gt;  LeftHandSideExpression
LeftHandSideExpression   -&gt;  NewExpression
NewExpression            -&gt;  MemberExpression
MemberExpression         -&gt;  PrimaryExpression
PrimaryExpression        -&gt;  IdentifierReference
</code></pre>
<p>言語仕様は、<code>IdentifierReference</code>と<code>Expression</code>の間に20の間接レベルを使用してJavaScript式の20の異なる優先度レベルをエンコードしている。
もし、言語仕様に従ってこのステートメントを表す具象構文木を作成すると、20のネストレベルがあり、実際のコードとは関係のない<code>BitwiseXORExpression</code>のような名前のノードが含まれる。</p>
<h3><a class="header" href="#優先度を使用する" id="優先度を使用する">優先度を使用する</a></h3>
<p>読みやすい構文木を生成するために、次のようなJavaScript式をより平らな構造でモデル化したい。</p>
<pre><code class="language-js">{
  // ...

  _expression: $ =&gt; choice(
    $.identifier,
    $.unary_expression,
    $.binary_expression,
    // ...
  ),

  unary_expression: $ =&gt; choice(
    seq('-', $._expression),
    seq('!', $._expression),
    // ...
  ),

  binary_expression: $ =&gt; choice(
    seq($._expression, '*', $._expression),
    seq($._expression, '+', $._expression),
    // ...
  ),
}
</code></pre>
<p>もちろん、この平坦な構造は非常に曖昧である。
もしパーサを生成しようとすると、Tree-sitterはエラーメッセージを表示する。</p>
<pre><code>Error: Unresolved conflict for symbol sequence:

  '-'  _expression  •  '*'  …

Possible interpretations:

  1:  '-'  (binary_expression  _expression  •  '*'  _expression)
  2:  (unary_expression  '-'  _expression)  •  '*'  …

Possible resolutions:

  1:  Specify a higher precedence in `binary_expression` than in the other rules.
  2:  Specify a higher precedence in `unary_expression` than in the other rules.
  3:  Specify a left or right associativity in `unary_expression`
  4:  Add a conflict for these rules: `binary_expression` `unary_expression`
</code></pre>
<p><code>-a * b</code>のような式では、<code>-</code>演算子が<code>a * b</code>に適用されるか、単に<code>a</code>に適用されるかが明確ではない。
これは、上記で説明した<code>prec</code>関数が役立つ場面である。
<code>prec</code>でルールをラップすることで、特定のシンボルのシーケンスが他のシーケンスよりも<em>密接に結びつく</em>べきであることを示すことができる。
例えば、<code>unary_expression</code>の<code>'-', $._expression</code>シーケンスは、<code>binary_expression</code>の<code>$._expression, '+', $._expression</code>シーケンスよりも密接に結びつくべきである。</p>
<pre><code class="language-js">{
  // ...

  unary_expression: $ =&gt; prec(2, choice(
    seq('-', $._expression),
    seq('!', $._expression),
    // ...
  ))
}
</code></pre>
<h3><a class="header" href="#using-associativity" id="using-associativity">Using Associativity</a></h3>
<p><code>unary_expression</code>の優先度を上げることで、このコンフリクトは解決されるが、別のコンフリクトが残る。</p>
<pre><code>Error: Unresolved conflict for symbol sequence:

  _expression  '*'  _expression  •  '*'  …

Possible interpretations:

  1:  _expression  '*'  (binary_expression  _expression  •  '*'  _expression)
  2:  (binary_expression  _expression  '*'  _expression)  •  '*'  …

Possible resolutions:

  1:  Specify a left or right associativity in `binary_expression`
  2:  Add a conflict for these rules: `binary_expression`
</code></pre>
<p><code>a * b * c</code>のような式では、<code>a * (b * c)</code>または<code>(a * b) * c</code>を意味するかが明確ではない。
これは<code>prec.left</code>と<code>prec.right</code>が使用される場面である。
ここでは2番目の解釈を選択したいので、<code>prec.left</code>を使用する。</p>
<pre><code class="language-js">{
  // ...

  binary_expression: $ =&gt; choice(
    prec.left(2, seq($._expression, '*', $._expression)),
    prec.left(1, seq($._expression, '+', $._expression)),
    // ...
  ),
}

```js
{
  // ...

  binary_expression: $ =&gt; choice(
    prec.left(2, seq($._expression, '*', $._expression)),
    prec.left(1, seq($._expression, '+', $._expression)),
    // ...
  ),
}
</code></pre>
<h3><a class="header" href="#隠蔽ルール" id="隠蔽ルール">隠蔽ルール</a></h3>
<p>上記の例では、<code>_expression</code>や<code>_type</code>のような構文ルールはアンダースコアから始まる。
アンダースコアから始まるルール名は、構文木で<em>隠される</em>。
これは、上記の文法の<code>_expression</code>のように常に単一の子ノードをラップするルールに便利である。
もしこれらのノードが隠されていない場合、構文木に大きな深さとノイズを追加し、理解が難しくなる。</p>
<h3><a class="header" href="#フィールドを使用する" id="フィールドを使用する">フィールドを使用する</a></h3>
<p>しばしば、構文ノードを解析する際に、順序付けられたリスト内の位置ではなく、名前で子ノードを参照できると便利である。
Tree-sitter文法は、<code>field</code>関数を使用してこれをサポートしています。
この関数を使用すると、ノードの一部またはすべての子に一意の名前を割り当てることができる。</p>
<pre><code class="language-js">function_definition: $ =&gt; seq(
  'func',
  field('name', $.identifier),
  field('parameters', $.parameter_list),
  field('return_type', $._type),
  field('body', $.block)
)
</code></pre>
<p>このようなフィールドを追加することで、<a href="./using-parsers#node-field-names">field API</a>を使用してノードを取得できるようになる。</p>
<h2><a class="header" href="#字句解析" id="字句解析">字句解析</a></h2>
<p>Tree-sitterの構文解析処理は、2つのフェーズに分かれている。
1つは構文解析（上記で説明した）で、もう1つは<a href="https://en.wikipedia.org/wiki/Lexical_analysis">字句解析</a>であり、字句解析は、個々の文字を言語の基本的な<em>トークン</em>にグループ化する処理である。
Tree-sitterの字句解析がどのように機能するかについて、いくつか重要なことがある。</p>
<h3><a class="header" href="#トークンの衝突" id="トークンの衝突">トークンの衝突</a></h3>
<p>文法はしばしば、同じ文字にマッチする複数のトークンを含んでいる。
例えば、文法には(<code>&quot;if&quot;</code>と<code>/[a-z]+/</code>)のトークンが含まれているかもしれない。
Tree-sitterは、これらのトークンの衝突をいくつかの方法で区別している。</p>
<ol>
<li>
<p><strong>外部スキャナー</strong> - 文法に外部スキャナーがある場合、<code>externals</code>配列内の1つ以上のトークンが現在の位置で有効である場合、外部スキャナーが常に最初に呼び出され、これらのトークンが存在するかどうかを決定する。</p>
</li>
<li>
<p><strong>Context-Aware Lexing</strong> - Tree-sitterは、パーサ実行時に必要に応じて字句解析を行う。ソースドキュメントの任意の位置で、字句解析器はその位置で<em>有効な</em>トークンのみを認識しようとする。</p>
</li>
<li>
<p><strong>Earliest Starting Position</strong> - Tree-sitter will prefer tokens with an earlier starting position. This is most often seen with very permissive regular expressions similar to <code>/.*/</code>, which are greedy and will consume as much text as possible. In this example the regex would consume all text until hitting a newline - even if text on that line could be interpreted as a different token.</p>
</li>
<li>
<p><strong>Explicit Lexical Precedence</strong> - When the precedence functions described <a href="section-3-creating-parsers.html#the-grammar-dsl">above</a> are used within the <code>token</code> function, the given precedence values serve as instructions to the lexer. If there are two valid tokens that match the characters at a given position in the document, Tree-sitter will select the one with the higher precedence.</p>
</li>
<li>
<p><strong>Match Length</strong> - If multiple valid tokens with the same precedence match the characters at a given position in a document, Tree-sitter will select the token that matches the <a href="https://en.wikipedia.org/wiki/Maximal_munch">longest sequence of characters</a>.</p>
</li>
<li>
<p><strong>Match Specificity</strong> - If there are two valid tokens with the same precedence and which both match the same number of characters, Tree-sitter will prefer a token that is specified in the grammar as a <code>String</code> over a token specified as a <code>RegExp</code>.</p>
</li>
<li>
<p><strong>Rule Order</strong> - If none of the above criteria can be used to select one token over another, Tree-sitter will prefer the token that appears earlier in the grammar.</p>
</li>
</ol>
<h3><a class="header" href="#lexical-precedence-vs-parse-precedence" id="lexical-precedence-vs-parse-precedence">Lexical Precedence vs. Parse Precedence</a></h3>
<p>One common mistake involves not distinguishing lexical precedence from parse precedence.
Parse precedence determines which rule is chosen to interpret a given sequence of tokens.
Lexical precedence determines which token is chosen to interpret a given section of text.
It is a lower-level operation that is done first.
The above list fully capture tree-sitter's lexical precedence rules, and you will probably refer back to this section of the documentation more often than any other.
Most of the time when you really get stuck, you're dealing with a lexical precedence problem.
Pay particular attention to the difference in meaning between using <code>prec</code> inside the <code>token</code> function versus outside of it.</p>
<h3><a class="header" href="#keywords" id="keywords">Keywords</a></h3>
<p>Many languages have a set of <em>keyword</em> tokens (e.g. <code>if</code>, <code>for</code>, <code>return</code>), as well as a more general token (e.g. <code>identifier</code>) that matches any word, including many of the keyword strings. For example, JavaScript has a keyword <code>instanceof</code>, which is used as a binary operator, like this:</p>
<pre><code class="language-js">if (a instanceof Something) b();
</code></pre>
<p>The following, however, is not valid JavaScript:</p>
<pre><code class="language-js">if (a instanceofSomething) b();
</code></pre>
<p>A keyword like <code>instanceof</code> cannot be followed immediately by another letter, because then it would be tokenized as an <code>identifier</code>, <strong>even though an identifier is not valid at that position</strong>. Because Tree-sitter uses context-aware lexing, as described <a href="section-3-creating-parsers.html#conflicting-tokens">above</a>, it would not normally impose this restriction. By default, Tree-sitter would recognize <code>instanceofSomething</code> as two separate tokens: the <code>instanceof</code> keyword followed by an <code>identifier</code>.</p>
<h3><a class="header" href="#keyword-extraction" id="keyword-extraction">Keyword Extraction</a></h3>
<p>Fortunately, Tree-sitter has a feature that allows you to fix this, so that you can match the behavior of other standard parsers: the <code>word</code> token. If you specify a <code>word</code> token in your grammar, Tree-sitter will find the set of <em>keyword</em> tokens that match strings also matched by the <code>word</code> token. Then, during lexing, instead of matching each of these keywords individually, Tree-sitter will match the keywords via a two-step process where it <em>first</em> matches the <code>word</code> token.</p>
<p>For example, suppose we added <code>identifier</code> as the <code>word</code> token in our JavaScript grammar:</p>
<pre><code class="language-js">grammar({
  name: 'javascript',

  word: $ =&gt; $.identifier,

  rules: {
    _expression: $ =&gt; choice(
      $.identifier,
      $.unary_expression,
      $.binary_expression
      // ...
    ),

    binary_expression: $ =&gt; choice(
      prec.left(1, seq($._expression, 'instanceof', $._expression)
      // ...
    ),

    unary_expression: $ =&gt; choice(
      prec.left(2, seq('typeof', $._expression))
      // ...
    ),

    identifier: $ =&gt; /[a-z_]+/
  }
});
</code></pre>
<p>Tree-sitter would identify <code>typeof</code> and <code>instanceof</code> as keywords. Then, when parsing the invalid code above, rather than scanning for the <code>instanceof</code> token individually, it would scan for an <code>identifier</code> first, and find <code>instanceofSomething</code>. It would then correctly recognize the code as invalid.</p>
<p>Aside from improving error detection, keyword extraction also has performance benefits. It allows Tree-sitter to generate a smaller, simpler lexing function, which means that <strong>the parser will compile much more quickly</strong>.</p>
<h3><a class="header" href="#external-scanners" id="external-scanners">External Scanners</a></h3>
<p>Many languages have some tokens whose structure is impossible or inconvenient to describe with a regular expression. Some examples:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Off-side_rule">Indent and dedent</a> tokens in Python</li>
<li><a href="https://en.wikipedia.org/wiki/Here_document">Heredocs</a> in Bash and Ruby</li>
<li><a href="https://docs.ruby-lang.org/en/2.5.0/doc/syntax/literals_rdoc.html#label-Percent+Strings">Percent strings</a> in Ruby</li>
</ul>
<p>Tree-sitter allows you to handle these kinds of tokens using <em>external scanners</em>. An external scanner is a set of C functions that you, the grammar author, can write by hand in order to add custom logic for recognizing certain tokens.</p>
<p>To use an external scanner, there are a few steps. First, add an <code>externals</code> section to your grammar. This section should list the names of all of your external tokens. These names can then be used elsewhere in your grammar.</p>
<pre><code class="language-js">grammar({
  name: 'my_language',

  externals: $ =&gt; [
    $.indent,
    $.dedent,
    $.newline
  ],

  // ...
});
</code></pre>
<p>Then, add another C or C++ source file to your project. Currently, its path must be <code>src/scanner.c</code> or <code>src/scanner.cc</code> for the CLI to recognize it. Be sure to add this file to the <code>sources</code> section of your <code>binding.gyp</code> file so that it will be included when your project is compiled by Node.js and uncomment the appropriate block in your <code>bindings/rust/build.rs</code> file so that it will be included in your Rust crate.</p>
<p>In this new source file, define an <a href="https://en.wikipedia.org/wiki/Enumerated_type#C"><code>enum</code></a> type containing the names of all of your external tokens. The ordering of this enum must match the order in your grammar's <code>externals</code> array; the actual names do not matter.</p>
<pre><code class="language-c">#include &lt;tree_sitter/parser.h&gt;

enum TokenType {
  INDENT,
  DEDENT,
  NEWLINE
}
</code></pre>
<p>Finally, you must define five functions with specific names, based on your language's name and five actions: <em>create</em>, <em>destroy</em>, <em>serialize</em>, <em>deserialize</em>, and <em>scan</em>. These functions must all use <a href="https://en.cppreference.com/w/cpp/language/language_linkage">C linkage</a>, so if you're writing the scanner in C++, you need to declare them with the <code>extern &quot;C&quot;</code> qualifier.</p>
<h4><a class="header" href="#create" id="create">Create</a></h4>
<pre><code class="language-c">void * tree_sitter_my_language_external_scanner_create() {
  // ...
}
</code></pre>
<p>This function should create your scanner object. It will only be called once anytime your language is set on a parser. Often, you will want to allocate memory on the heap and return a pointer to it. If your external scanner doesn't need to maintain any state, it's ok to return <code>NULL</code>.</p>
<h4><a class="header" href="#destroy" id="destroy">Destroy</a></h4>
<pre><code class="language-c">void tree_sitter_my_language_external_scanner_destroy(void *payload) {
  // ...
}
</code></pre>
<p>This function should free any memory used by your scanner. It is called once when a parser is deleted or assigned a different language. It receives as an argument the same pointer that was returned from the <em>create</em> function. If your <em>create</em> function didn't allocate any memory, this function can be a noop.</p>
<h4><a class="header" href="#serialize" id="serialize">Serialize</a></h4>
<pre><code class="language-c">unsigned tree_sitter_my_language_external_scanner_serialize(
  void *payload,
  char *buffer
) {
  // ...
}
</code></pre>
<p>This function should copy the complete state of your scanner into a given byte buffer, and return the number of bytes written. The function is called every time the external scanner successfully recognizes a token. It receives a pointer to your scanner and a pointer to a buffer. The maximum number of bytes that you can write is given by the <code>TREE_SITTER_SERIALIZATION_BUFFER_SIZE</code> constant, defined in the <code>tree_sitter/parser.h</code> header file.</p>
<p>The data that this function writes will ultimately be stored in the syntax tree so that the scanner can be restored to the right state when handling edits or ambiguities. For your parser to work correctly, the <code>serialize</code> function must store its entire state, and <code>deserialize</code> must restore the entire state. For good performance, you should design your scanner so that its state can be serialized as quickly and compactly as possible.</p>
<h4><a class="header" href="#deserialize" id="deserialize">Deserialize</a></h4>
<pre><code class="language-c">void tree_sitter_my_language_external_scanner_deserialize(
  void *payload,
  const char *buffer,
  unsigned length
) {
  // ...
}
</code></pre>
<p>This function should <em>restore</em> the state of your scanner based the bytes that were previously written by the <code>serialize</code> function. It is called with a pointer to your scanner, a pointer to the buffer of bytes, and the number of bytes that should be read.
It is good practice to explicitly erase your scanner state variables at the start of this function, before restoring their values from the byte buffer.</p>
<h4><a class="header" href="#scan" id="scan">Scan</a></h4>
<pre><code class="language-c">bool tree_sitter_my_language_external_scanner_scan(
  void *payload,
  TSLexer *lexer,
  const bool *valid_symbols
) {
  // ...
}
</code></pre>
<p>This function is responsible for recognizing external tokens. It should return <code>true</code> if a token was recognized, and <code>false</code> otherwise. It is called with a &quot;lexer&quot; struct with the following fields:</p>
<ul>
<li><strong><code>int32_t lookahead</code></strong> - The current next character in the input stream, represented as a 32-bit unicode code point.</li>
<li><strong><code>TSSymbol result_symbol</code></strong> - The symbol that was recognized. Your scan function should <em>assign</em> to this field one of the values from the <code>TokenType</code> enum, described above.</li>
<li><strong><code>void (*advance)(TSLexer *, bool skip)</code></strong> - A function for advancing to the next character. If you pass <code>true</code> for the second argument, the current character will be treated as whitespace; whitespace won't be included in the text range associated with tokens emitted by the external scanner.</li>
<li><strong><code>void (*mark_end)(TSLexer *)</code></strong> - A function for marking the end of the recognized token. This allows matching tokens that require multiple characters of lookahead. By default (if you don't call <code>mark_end</code>), any character that you moved past using the <code>advance</code> function will be included in the size of the token. But once you call <code>mark_end</code>, then any later calls to <code>advance</code> will <em>not</em> increase the size of the returned token. You can call <code>mark_end</code> multiple times to increase the size of the token.</li>
<li><strong><code>uint32_t (*get_column)(TSLexer *)</code></strong> - A function for querying the current column position of the lexer. It returns the number of codepoints since the start of the current line. The codepoint position is recalculated on every call to this function by reading from the start of the line.</li>
<li><strong><code>bool (*is_at_included_range_start)(const TSLexer *)</code></strong> - A function for checking whether the parser has just skipped some characters in the document. When parsing an embedded document using the <code>ts_parser_set_included_ranges</code> function (described in the <a href="./using-parsers#multi-language-documents">multi-language document section</a>), your scanner may want to apply some special behavior when moving to a disjoint part of the document. For example, in <a href="https://ejs.co">EJS documents</a>, the JavaScript parser uses this function to enable inserting automatic semicolon tokens in between the code directives, delimited by <code>&lt;%</code> and <code>%&gt;</code>.</li>
<li><strong><code>bool (*eof)(const TSLexer *)</code></strong> - A function for determining whether the lexer is at the end of the file. The value of <code>lookahead</code> will be <code>0</code> at the end of a file, but this function should be used instead of checking for that value because the <code>0</code> or &quot;NUL&quot; value is also a valid character that could be present in the file being parsed.</li>
</ul>
<p>The third argument to the <code>scan</code> function is an array of booleans that indicates which of your external tokens are currently expected by the parser. You should only look for a given token if it is valid according to this array. At the same time, you cannot backtrack, so you may need to combine certain pieces of logic.</p>
<pre><code class="language-c">if (valid_symbols[INDENT] || valid_symbol[DEDENT]) {

  // ... logic that is common to both `INDENT` and `DEDENT`

  if (valid_symbols[INDENT]) {

    // ... logic that is specific to `INDENT`

    lexer-&gt;result_symbol = INDENT;
    return true;
  }
}
</code></pre>
<h4><a class="header" href="#other-external-scanner-details" id="other-external-scanner-details">Other External Scanner Details</a></h4>
<p>If a token in your <code>externals</code> array is valid at the current position in the parse, your external scanner will be called first before anything else is done.
This means your external scanner functions as a powerful override of tree-sitter's lexing behavior, and can be used to solve problems that can't be cracked with ordinary lexical, parse, or dynamic precedence.</p>
<p>If a syntax error is encountered during regular parsing, tree-sitter's first action during error recovery will be to call your external scanner's <code>scan</code> function with all tokens marked valid.
Your scanner should detect this case and handle it appropriately.
One simple method of detection is to add an unused token to the end of your <code>externals</code> array, for example <code>externals: $ =&gt; [$.token1, $.token2, $.error_sentinel]</code>, then check whether that token is marked valid to determine whether tree-sitter is in error correction mode.</p>
<p>If you put terminal keywords in your <code>externals</code> array, for example <code>externals: $ =&gt; ['if', 'then', 'else']</code>, then any time those terminals are present in your grammar they will be tokenized by your external scanner.
It is equivalent to writing <code>externals: [$.if_keyword, $.then_keyword, $.else_keyword]</code> then using <code>alias($.if_keyword, 'if')</code> in your grammar.</p>
<p>External scanners are a common cause of infinite loops.
Be very careful when emitting zero-width tokens from your external scanner, and if you consume characters in a loop be sure use the <code>eof</code> function to check whether you are at the end of the file.</p>
<!-- textlint-enable -->
<p><a href="./section-2-using-parsers.html">前のページ(パーサを使う)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-4-syntax-highlighting.html">次のページ(シンタックスハイライター)</a></p>
<p><a href="./section-3-creating-parsers.html">前のページ(パーサを作る)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-5-implementation.html">次のページ(Tree-sitterの実装)</a></p>
<h1><a class="header" href="#シンタックスハイライト" id="シンタックスハイライト">シンタックスハイライト</a></h1>
<p>シンタックスハイライトはコードを扱うアプリケーションで使われることが多い機能である。
Tree-sitterはシンタックスハイライトをサポートする<a href="https://github.com/tree-sitter/tree-sitter/tree/master/highlight"><code>tree-sitter-highlight</code></a>
ライブラリをビルトインで提供する。
<code>tree-sitter-highlight</code>は現在、GitHub.comにおいて多くの言語のシンタックスハイライトで使用されている。</p>
<!-- textlint-disable -->
<p>コマンドラインから<code>tree-sitter highlight</code>コマンドを使うことで、シンタクスハイライト機能を実行できる。</p>
<!-- textlint-enable -->
<p>このページでは、CLIを使って、どのようにTree-sitterのシンタックスハイライト機能が動作するのかを解説する。
もし<code>tree-sitter-highlight</code>ライブラリ（CまたはRustから使用可能）を利用する場合、これらの考え方は有用であるが、設定データはファイルではなくメモリ上のオブジェクトである。</p>
<!-- textlint-disable -->
<p><strong>注意 - もしテキストエディタの<a href="https://atom.io/">Atom</a>のシンタックスハイライトを開発する場合は、このドキュメントでなくAtom Flight Mantualの<a href="https://flight-manual.atom.io/hacking-atom/sections/creating-a-grammar/">このページ</a>を参照せよ。</strong></p>
<!-- textlint-enable -->
<p><strong>Atomは現在Tree-sitterベースの別のシンタックスハイライトシステムを採用していいて、それはここで説明するよりも古いものである。</strong></p>
<!-- textlint-disable -->
<h2><a class="header" href="#概要-1" id="概要-1">概要</a></h2>
<p>通常、与えられた言語のハイライトに必要なファイルは、その言語のTree-sitterの文法と同じgitリポジトリに含まれている。
（例えば、<a href="https://github.com/tree-sitter/tree-sitter-javascript"><code>tree-sitter-javascript</code></a>, <a href="https://github.com/tree-sitter/tree-sitter-ruby"><code>tree-sitter-ruby</code></a>)
コマンドラインからシンタックスハイライトを実行するためには、次の3つが必要である。</p>
<ol>
<li><code>~/.config/tree-sitter/config.json</code>に記載されたユーザ固有の設定。</li>
<li>文法リポジトリの<code>package.json</code>ファイルに記載された言語の設定。</li>
<li>文法リポジトリの<code>queries</code>フォルダにある3つのクエリ。</li>
</ol>
<p>言語固有のファイルの例については、<code>tree-sitter-ruby</code>リポジトリの<a href="https://github.com/tree-sitter/tree-sitter-ruby/blob/master/package.json"><code>package.json</code>ファイル</a>と<a href="https://github.com/tree-sitter/tree-sitter-ruby/tree/master/queries"><code>queries</code>ディレクトリ</a>を参照せよ。
以下のセクションでは、各ファイルの動作について説明する。</p>
<h2><a class="header" href="#ユーザ固有の設定" id="ユーザ固有の設定">ユーザ固有の設定</a></h2>
<p>tree-sitterのCLIは自動的にホームフォルダに2つのディレクトリを作成する。
一方のディレクトリには、CLIの動作を規定するJSON形式の設定ファイルが格納される。
もう一方のディレクトリには、言語ごとのコンパイル済みのパーサが格納される。</p>
<p>これらのディレクトリは、各プラットフォームの「通常の」場所に作成される。</p>
<ul>
<li>Linuxでは、<code>~/.config/tree-sitter</code>と<code>~/.cache/tree-sitter</code></li>
<li>Macでは、<code>~/Library/Application Support/tree-sitter</code>と<code>~/Library/Caches/tree-sitter</code></li>
<li>Windowsでは、<code>C:\Users\[ユーザ名]\AppData\Roaming\tree-sitter</code> と <code>C:\Users\[ユーザ名]\AppData\Local\tree-sitter</code></li>
</ul>
<p>CLIは設定ファイルが存在しない場合、各設定オプションのデフォルト値を使用して動作する。
設定ファイルを作成し、編集するためには、次のコマンドを実行する。</p>
<pre><code class="language-sh">tree-sitter init-config
</code></pre>
<p>(これにより、作成されたファイルの場所が表示されるため、簡単に見つけて編集できる。)</p>
<h3><a class="header" href="#パス" id="パス">パス</a></h3>
<p><code>tree-sitter highlight</code>コマンドは1つ以上のファイルパスを取り、それらのファイルをハイライトするためにどの言語を使用するかを自動的に決定しようとする。
これを行うためには、ファイルシステム上でTree-sitterの文法を探す場所を知る必要がある。
これは設定ファイルの<code>&quot;parser-directories&quot;</code>キーを使って制御できる。</p>
<pre><code class="language-json">{
  &quot;parser-directories&quot;: [
    &quot;/Users/my-name/code&quot;,
    &quot;/Users/my-name/other-code&quot;
  ]
}
</code></pre>
<p>今のところ、これらの<em>parser-directories</em>のいずれかにある、名前が<code>tree-sitter-</code>で始まるフォルダは、Tree-sitterの文法リポジトリとして扱われる。</p>
<h3><a class="header" href="#テーマ" id="テーマ">テーマ</a></h3>
<p>Tree-sitterのハイライトシステムは、<code>function.method</code>、<code>type.builtin</code>、<code>keyword</code>などの論理的な「ハイライト名」でソースコードの範囲を注釈付けすることで動作する。
各ハイライトのレンダリングに使用する色を決定するためには、<em>theme</em>が必要である。</p>
<pre><code class="language-json">{
  &quot;theme&quot;: {
    &quot;function.method&quot;: &quot;blue&quot;,
    &quot;type.builtin&quot;: &quot;green&quot;,
    &quot;keyword&quot;: &quot;purple&quot;
  }
}
</code></pre>
<p>設定ファイルにおいて、<code>&quot;theme&quot;</code>の値は、<code>function.builtin</code>や<code>keyword</code>のようなドットで区切られたハイライト名であり、その値はテキストのスタイリングパラメータを表すJSONの式である。</p>
<h4><a class="header" href="#ハイライト名" id="ハイライト名">ハイライト名</a></h4>
<p>テーマは共通の部分文字列を持つ複数のキーを含むことができる。
例えば、</p>
<ul>
<li><code>variable</code>,  <code>variable.parameter</code></li>
<li><code>function</code>, <code>function.builtin</code>,  <code>function.method</code></li>
</ul>
<p>与えられたハイライトに対して、スタイリングに合致するテーマキーが複数存在する場合<strong>最も長いテーマキー</strong>が選択される。
例えば、<code>function.builtin.static</code>というハイライトは、<code>function</code>よりも<code>function.builtin</code>にマッチする。</p>
<h4><a class="header" href="#スタイリング値" id="スタイリング値">スタイリング値</a></h4>
<p>スタイリング値は以下のいずれかである。</p>
<ul>
<li>ASNIのターミナルカラーIDを表す0から255までの整数。</li>
<li><code>&quot;#e45649&quot;</code>のような16進RGBカラーを表す文字列。</li>
<li><code>&quot;red&quot;</code>, <code>&quot;black&quot;</code>, <code>&quot;purple&quot;</code>, <code>&quot;cyan&quot;</code>といったANSIカラーを表す文字列。</li>
<li>以下のキーを持つオブジェクト。
<ul>
<li><code>color</code> - 整数または上記の文字列。</li>
<li><code>underline</code> - テキストを下線にするかどうかを示すブール値。</li>
<li><code>italic</code> - テキストを斜体にするかどうかを示すブール値。</li>
<li><code>bold</code> - テキストを太字にするかどうかを示すブール値。</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#言語設定" id="言語設定">言語設定</a></h2>
<p><code>package.json</code>ファイルは<code>npm</code>のようなパッケージマネージャによって使用される。
このファイルでは、Tree-sitter CLIはトップレベルの<code>&quot;tree-sitter&quot;</code>キーの下にネストされたデータを探す。
このキーは、以下のキーを持つオブジェクトの配列を含むことが期待される。</p>
<h3><a class="header" href="#基本" id="基本">基本</a></h3>
<p>これらのキーはパーサに関する基本的な情報を指定する。</p>
<ul>
<li>
<p><code>scope</code> (必須) - <code>&quot;source.js&quot;</code>のような言語を識別する文字列。現在我々は人気のある<a href="https://macromates.com/manual/en/language_grammars">TextMate grammars</a>や<a href="https://github.com/github/linguist">Linguist</a>で使用されるスコープ名に一致するよう努めている。</p>
</li>
<li>
<p><code>path</code> (任意) - <code>package.json</code>を含むディレクトリから、実際の生成されたパーサを含む<code>src/</code>フォルダへの相対パス。デフォルト値は<code>&quot;.&quot;</code>（つまり<code>src/</code>は<code>package.json</code>と同じフォルダにある）であり、これを上書きする必要がある場合は非常に稀である。</p>
</li>
</ul>
<h3><a class="header" href="#言語の検出" id="言語の検出">言語の検出</a></h3>
<p>これらのキーは、与えられたファイルにどの言語を適用するかを決定するのに役立つ。</p>
<ul>
<li>
<p><code>file-type</code> - ファイル名の接尾辞の配列。文法は、これらの接尾辞のいずれかで終わるファイルに使用される。接尾辞は<em>ファイル名全体</em>に一致する可能性があることに注意。</p>
</li>
<li>
<p><code>first-line-regex</code> - ファイルの最初の行に対してテストされる正規表現パターン。この言語がファイルに適用されるかどうかを決定するために使用される。この正規表現が指定されている場合、この正規表現は言語がいずれの文法の<code>file-types</code>にも一致しないファイルに使用される。</p>
</li>
<li>
<p><code>content-regex</code> - 上記の2つの基準を使用してファイルに複数の文法が一致した場合に、ファイルの内容に対してテストされる正規表現パターン。この正規表現に一致する場合、この文法は<code>content-regex</code>を持たない他の文法よりも優先される。正規表現が一致しない場合、<code>content-regex</code>を持たない文法がこの文法よりも優先される。</p>
</li>
<li>
<p><code>injection-regex</code> - この言語が潜在的な<em>言語インジェクション</em>サイトに使用されるかどうかを決定するために、<em>言語名</em>に対してテストされる正規表現パターン。言語インジェクションについては、<a href="section-4-syntax-highlighting.html#%E8%A8%80%E8%AA%9E%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">後のセクション</a>で詳しく説明する。</p>
</li>
</ul>
<h3><a class="header" href="#クエリパス" id="クエリパス">クエリパス</a></h3>
<p>これらのキーは、<code>package.json</code>を含むディレクトリから、シンタックスハイライトを制御するファイルへの相対パスを指定する。</p>
<ul>
<li><code>highlights</code> - <em>ハイライトクエリ</em>へのパス。デフォルト値は<code>queries/highlights.scm</code>である。</li>
<li><code>locals</code> - <em>ローカル変数クエリ</em>へのパス。デフォルト値は<code>queries/locals.scm</code>である。</li>
<li><code>injections</code> - <em>インジェクションクエリ</em>へのパス。デフォルト値は<code>queries/injections.scm</code>である。</li>
</ul>
<p>これらの3つのファイルの動作については、次のセクションで説明する。</p>
<h3><a class="header" href="#例" id="例">例</a></h3>
<p>一般的に、<code>&quot;tree-sitter&quot;</code>配列は1つのオブジェクトだけを含めば十分で、そのオブジェクトにはいくつかのキーを指定するだけでよい。</p>
<pre><code class="language-json">{
  &quot;tree-sitter&quot;: [
    {
      &quot;scope&quot;: &quot;source.ruby&quot;,
      &quot;file-types&quot;: [
        &quot;rb&quot;,
        &quot;gemspec&quot;,
        &quot;Gemfile&quot;,
        &quot;Rakefile&quot;
      ],
      &quot;first-line-regex&quot;: &quot;#!.*\\bruby$&quot;
    }
  ]
}
</code></pre>
<h2><a class="header" href="#クエリ" id="クエリ">クエリ</a></h2>
<p>Tree-sitterのシンタックスハイライトの仕組みは、Tree-sitterの構文木にパターンマッチングする一般的なシステムである<em>tree queries</em>に基づいている。
tree queriesについての詳細は<a href="./using-parsers#pattern-matching-with-queries">このセクション</a>を参照せよ。</p>
<p>シンタックスハイライトは、<code>queries</code>フォルダに格納される3種類のクエリファイルによって制御される。
デフォルトでは、クエリファイルの名前は<code>.scm</code>ファイルを使用する。
この拡張子を採用した理由は、クエリがLispの一般的な方言である<a href="https://ja.wikipedia.org/wiki/Scheme">Scheme</a>に似た構文を使用しているためである。</p>
<p>また、<code>.scm</code>を「Source Code Matching」の略と考えることもできる。</p>
<h3><a class="header" href="#ハイライトクエリ" id="ハイライトクエリ">ハイライトクエリ</a></h3>
<p>最も重要なクエリは、ハイライトクエリである。
ハイライトクエリは、異なるノードに任意の<em>ハイライト名</em>を割り当てるために<em>キャプチャ</em>を使用する。
各ハイライト名には、それぞれ色が割り当てられる（<a href="section-4-syntax-highlighting.html#theme">上記</a>参照）。
一般的に使用されるハイライト名には、<code>keyword</code>、<code>function</code>、<code>type</code>、<code>property</code>、<code>string</code>などがある。
ハイライト名は、<code>function.builtin</code>のようにドットで区切ることもできる。</p>
<h4><a class="header" href="#例-1" id="例-1">例</a></h4>
<p>例として、下記のGo言語のコードを考える。</p>
<pre><code class="language-go">func increment(a int) int {
    return a + 1
}
</code></pre>
<p>構文木は下記の通りである。</p>
<pre><code>(source_file
  (function_declaration
    name: (identifier)
    parameters: (parameter_list
      (parameter_declaration
        name: (identifier)
        type: (type_identifier)))
    result: (type_identifier)
    body: (block
      (return_statement
        (expression_list
          (binary_expression
            left: (identifier)
            right: (int_literal)))))))
</code></pre>
<h4><a class="header" href="#クエリの例" id="クエリの例">クエリの例</a></h4>
<p>下記の色でこのコードをレンダリングしたいとする。</p>
<ul>
<li>キーワード<code>func</code>と<code>return</code>は紫色</li>
<li>関数<code>increment</code>は青色</li>
<li>型<code>int</code>は緑色</li>
<li>数字<code>5</code>は茶色</li>
</ul>
<p>下記のようなクエリを使用することで、それぞれのカテゴリに<em>ハイライト名</em>を割り当てることができる。</p>
<pre><code>; highlights.scm

&quot;func&quot; @keyword
&quot;return&quot; @keyword
(type_identifier) @type
(int_literal) @number
(function_declaration name: (identifier) @function)
</code></pre>
<p>設定ファイルでは、これらのハイライト名を色にマッピングすることができる。</p>
<pre><code class="language-json">{
  &quot;theme&quot;: {
    &quot;keyword&quot;: &quot;purple&quot;,
    &quot;function&quot;: &quot;blue&quot;,
    &quot;type&quot;: &quot;green&quot;,
    &quot;number&quot;: &quot;brown&quot;
  }
}
</code></pre>
<h4><a class="header" href="#結果" id="結果">結果</a></h4>
<p><code>tree-sitter highlight</code>をこのGoファイルで実行すると、次のような出力が得られる。</p>
<pre class='highlight' style='border: 1px solid #aaa;'>
<span style='color: purple;'>func</span> <span style='color: #005fd7;'>increment</span>(<span>a</span> <span style='color: green;'>int</span>) <span style='color: green;'>int</span> {
    <span style='color: purple;'>return</span> <span>a</span> <span style='font-weight: bold;color: #4e4e4e;'>+</span> <span style='font-weight: bold;color: #875f00;'>1</span>
}
</pre>
<h3><a class="header" href="#ローカル変数" id="ローカル変数">ローカル変数</a></h3>
<p>優れたシンタックスハイライトは、コード内の異なる<em>エンティティ</em>を素早く区別できるようにする。
理想的には、特定のエンティティが<em>複数</em>の場所に現れる場合、それぞれの場所で同じ色で表示されるべきである。
Tree-sitterのシンタックスハイライトシステムは、ローカルスコープと変数を追跡することで、これを実現する。</p>
<p><em>ローカル変数</em>クエリは、<em>任意の</em>キャプチャ名を使用しそれを色にマッピングするハイライトへクリと異なり、特別な意味を持つ固定されたキャプチャ名を使用する。</p>
<p>キャプチャ名は以下の通りである。</p>
<ul>
<li><code>@local.scope</code> - シンタックスノードが新しいローカルスコープを導入することを示す。</li>
<li><code>@local.definition</code> - シンタックスノードが現在のローカルスコープ内の定義の<em>名前</em>を含むことを示す。</li>
<li><code>@local.reference</code> - シンタックスノードが、いくつかの包含スコープ内の以前の定義を参照する<em>名前</em>を含むことを示す。</li>
</ul>
<p>ファイルをハイライトするとき、tree-sitterは与えられた位置を含むスコープの集合と、各スコープ内の定義の集合を追跡する。
<code>local.reference</code>としてキャプチャされた構文ノードを処理するとき、Tree-sitterはノードのテキストに一致する名前の定義を検索する。
一致するものが見つかった場合、Tree-sitterは<em>参照</em>と<em>定義</em>が同じ色で表示されるようにする。</p>
<p>このクエリによって生成された情報は、ハイライトクエリによっても<em>使用</em>される。
ローカル変数として識別されたノードに対して<code>(#is-not? local)</code>述語をパターンに追加することで、そのパターンを無効にすることができる。</p>
<h4><a class="header" href="#例-2" id="例-2">例</a></h4>
<p>下記のRubyコードを考える。</p>
<pre><code class="language-ruby">def process_list(list)
  context = current_context
  list.map do |item|
    process_item(item, context)
  end
end

item = 5
list = [item]
</code></pre>
<p>構文木は下記の通りである。</p>
<pre><code>(program
  (method
    name: (identifier)
    parameters: (method_parameters
      (identifier))
    (assignment
      left: (identifier)
      right: (identifier))
    (method_call
      method: (call
        receiver: (identifier)
        method: (identifier))
      block: (do_block
        (block_parameters
          (identifier))
        (method_call
          method: (identifier)
          arguments: (argument_list
            (identifier)
            (identifier))))))
  (assignment
    left: (identifier)
    right: (integer))
  (assignment
    left: (identifier)
    right: (array
      (identifier))))
</code></pre>
<p>メソッドの中にはいくつかの異なる種類の名前がある。</p>
<ul>
<li><code>process_list</code>はメソッドである。</li>
<li>メソッド内で<code>list</code>は形式パラメータである。</li>
<li><code>context</code>はローカル変数である。</li>
<li><code>current_context</code>はローカル変数ではないので、メソッドである。</li>
<li>doブロック内で、<code>item</code>は形式パラメータである。</li>
<li>さらに、<code>item</code>と<code>list</code>はどちらもローカル変数である（形式パラメータではない）。</li>
</ul>
<h4><a class="header" href="#クエリの例-1" id="クエリの例-1">クエリの例</a></h4>
<p>これらの名前の種類を明確に区別できるようにするために、いくつかのクエリを示す。
まず、前のセクションで説明したように、ハイライトクエリを設定する。
メソッド呼び出し、メソッド定義、形式パラメータに異なる色を割り当てる。</p>
<pre><code>; highlights.scm

(call method: (identifier) @function.method)
(method_call method: (identifier) @function.method)

(method name: (identifier) @function.method)

(method_parameters (identifier) @variable.parameter)
(block_parameters (identifier) @variable.parameter)

((identifier) @function.method
 (#is-not? local))
</code></pre>
<p>その後、変数とスコープを追跡するためのローカル変数クエリを設定する。
ここでは、メソッドとブロックがローカル<em>スコープ</em>を作成し、パラメータと代入が<em>定義</em>を作成し、他の識別子は<em>参照</em>として扱われることを示している。</p>
<pre><code>; locals.scm

(method) @local.scope
(do_block) @local.scope

(method_parameters (identifier) @local.definition)
(block_parameters (identifier) @local.definition)

(assignment left:(identifier) @local.definition)

(identifier) @local.reference
</code></pre>
<h4><a class="header" href="#結果-1" id="結果-1">結果</a></h4>
<p>rubyファイルで<code>tree-sitter highlight</code>を実行すると、次のような出力が得られる。</p>
<pre class='highlight' style='border: 1px solid #aaa;'>
<span style='color: purple;'>def</span> <span style='color: #005fd7;'>process_list</span><span style='color: #4e4e4e;'>(</span><span style='text-decoration: underline;'>list</span><span style='color: #4e4e4e;'>)</span>
  <span>context</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> <span style='color: #005fd7;'>current_context</span>
  <span style='text-decoration: underline;'>list</span><span style='color: #4e4e4e;'>.</span><span style='color: #005fd7;'>map</span> <span style='color: purple;'>do</span> |<span style='text-decoration: underline;'>item</span>|
    <span style='color: #005fd7;'>process_item</span>(<span style='text-decoration: underline;'>item</span><span style='color: #4e4e4e;'>,</span> <span>context</span><span style='color: #4e4e4e;'>)</span>
  <span style='color: purple;'>end</span>
<span style='color: purple;'>end</span>

<span>item</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> <span style='font-weight: bold;color: #875f00;'>5</span>
<span>list</span> <span style='font-weight: bold;color: #4e4e4e;'>=</span> [<span>item</span><span style='color: #4e4e4e;'>]</span>
</pre>
<h3><a class="header" href="#言語インジェクション" id="言語インジェクション">言語インジェクション</a></h3>
<p>いくつかのソースファイルには、複数の異なる言語で書かれたコードが含まれている。例としては、</p>
<ul>
<li>HTMLファイルは、<code>&lt;script&gt;</code>タグ内にJavaScript、<code>&lt;style&gt;</code>タグ内にCSSを含めることができる。</li>
<li><a href="https://en.wikipedia.org/wiki/ERuby">ERB</a>ファイルは、<code>&lt;% %&gt;</code>タグ内にRubyを含み、それ以外の部分にHTMLを含めることができる。</li>
<li>PHPファイルは、<code>&lt;php</code>タグ内にHTMLを含めることができる。</li>
<li>JavaScriptファイルは、正規表現リテラル内に正規表現構文を含む。</li>
<li>Rubyはヒアドキュメント内にコードスニペットを含むことができ、ヒアドキュメントの区切り文字にはそのコードスニペットの言語を示す語が使われる。</li>
</ul>
<p>これらの例はすべて、<em>親</em>構文木と、ノードの内部に存在する1つ以上の<em>インジェクション</em>構文木を使用してモデル化できる。
言語インジェクションクエリを使用すると、これらの「インジェクション」を次のキャプチャを使用して指定できる。</p>
<ul>
<li><code>@injection.content</code> - キャプチャされたノードの内容を別の言語を使用して再解析することを示す。</li>
<li><code>@injection.language</code> - キャプチャされたノードのテキストが、<code>@injection.content</code>を再解析するために使用される言語の<em>名前</em>を含む可能性があることを示す。</li>
</ul>
<p>言語インジェクションの動作は、パターンに関連付けられたいくつかのプロパティによっても設定できる。</p>
<ul>
<li><code>injection.language</code> - 特定の言語の名前をハードコードするために使用する。</li>
<li><code>injection.combined</code> - 一致するノードの<em>すべて</em>の内容が<em>1つ</em>の入れ子ドキュメントとして解析されるべきであることを示す。</li>
<li><code>injection.include-children</code> - <code>@injection.content</code>ノードの<em>全体</em>のテキストが再解析されるべきであることを示す。デフォルトでは、子ノードのテキストはインジェクトされたドキュメントから<em>除外</em>される。</li>
</ul>
<h4><a class="header" href="#例-3" id="例-3">例</a></h4>
<p>下記のRubyコードを考える。</p>
<pre><code class="language-ruby">system &lt;&lt;-BASH.strip!
  abc --def | ghi &gt; jkl
BASH
</code></pre>
<p>構文木は下記の通りである。</p>
<pre><code>(program
  (method_call
    method: (identifier)
    arguments: (argument_list
      (call
        receiver: (heredoc_beginning)
        method: (identifier))))
  (heredoc_body
    (heredoc_end)))
</code></pre>
<p>下記のクエリは、ヒアドキュメントの内容を「BASH」という名前の言語を使用して解析することを指定する。(なぜなら、これは<code>heredoc_end</code>ノードのテキストであるため)</p>
<pre><code>(heredoc_body
  (heredoc_end) @injection.language) @injection.content
</code></pre>
<p><code>#set!</code>述語を使用して言語を強制することもできる。
例えば、これは常に言語を<code>ruby</code>に強制する。</p>
<pre><code>((heredoc_body) @injection.content
 (#set! injection.language &quot;ruby&quot;))
</code></pre>
<h2><a class="header" href="#ユニットテスト" id="ユニットテスト">ユニットテスト</a></h2>
<p>Tree-sitterは、シンタックスハイライトの結果を検証方法がするための組み込まれている。
このインターフェースは、<a href="https://www.sublimetext.com/docs/3/syntax.html#testing">Sublime Textシンタックスハイライトのテスト</a>に基づいている。</p>
<p>テストは、特別なフォーマットのコメントを含む通常のソースコードファイルとして書かれる。
このコメントは、周囲のシンタックスハイライトについてのアサーションを行う。
これらのファイルは、文法リポジトリの<code>test/highlight</code>ディレクトリに格納される。</p>
<p>ここにJavaScriptのシンタックスハイライトテストの例を示す。</p>
<pre><code class="language-js">var abc = function(d) {
  // &lt;- keyword
  //          ^ keyword
  //               ^ variable.parameter
  // ^ function

  if (a) {
  // &lt;- keyword
  // ^ punctuation.bracket

    foo(`foo ${bar}`);
    // &lt;- function
    //    ^ string
    //          ^ variable
  }
};
</code></pre>
<p>以下はSublime Textのドキュメントからの引用である。</p>
<blockquote>
<p>The two types of tests are:</p>
<p><strong>Caret</strong>: ^ this will test the following selector against the scope on the most recent non-test line. It will test it at the same column the ^ is in. Consecutive ^s will test each column against the selector.</p>
<p><strong>Arrow</strong>: &lt;- this will test the following selector against the scope on the most recent non-test line. It will test it at the same column as the comment character is in.</p>
</blockquote>
<p>下記は上記のドキュメントの日本語訳である</p>
<blockquote>
<p><strong>キャレット</strong>: ^ これは、直近の非テスト行のスコープに対して、次のセレクタをテストする。 ^がある列でテストする。連続する^は、各列をセレクタに対してテストします。
<strong>アロー</strong>: &lt;- これは、直近の非テスト行のスコープに対して、次のセレクタをテストする。コメント文字がある列でテストする。</p>
</blockquote>
<!-- textlint-enable -->
<p><a href="./section-3-creating-parsers.html">前のページ(パーサを作る)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-5-implementation.html">次のページ(Tree-sitterの実装)</a></p>
<p><a href="./section-4-syntax-highlighting.html">前のページ(シンタックスハイライター)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-6-contributing.html">次のページ(コントリビュート)</a></p>
<h1><a class="header" href="#実装" id="実装">実装</a></h1>
<p>Tree-sitterCライブラリ（<code>libtree-sitter</code>）とコマンドラインツール（<code>tree-sitter</code> CLI）の2つのコンポーネントで構成されている。</p>
<p><code>libtree-sitter</code>はCLIで生成されたパーサーと組み合わせて、ソースコードから構文木を生成し、ソースコードが変更されるたびに構文木を最新の状態に保つ。
<code>libtree-sitter</code>はプレーンなC言語で書かれ、アプリケーションに埋め込むことを想定して設計されている。
そのインターフェースはヘッダファイル<a href="https://github.com/tree-sitter/tree-sitter/blob/master/lib/include/tree_sitter/api.h"><code>tree_sitter/api.h</code></a>で定義される。</p>
<p>CLIは、言語を記述する文脈自由文法を提供することで、言語のパーサーを生成できる。
CLIはビルドツールであり、一度パーサーが生成されると不要になる。
パーサはRustで書かれており、<a href="https://crates.io">crates.io</a>や<a href="http://npmjs.com">npm</a>から利用でき、またビルド済みバイナリを<a href="https://github.com/tree-sitter/tree-sitter/releases/latest">GitHub</a>からダウンロードできる。</p>
<h2><a class="header" href="#the-cli" id="the-cli">The CLI</a></h2>
<p><code>tree-sitter</code> CLIの最も重要な機能は、サブコマンドの<code>generate</code>である。
このサブコマンドは文脈自由文法を<code>grammar.js</code>というファイルから読み込み、<code>parser.c</code>というCファイルとしてパーサを出力する。
<a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli/src"><code>cli/src</code></a>ディレクトリのソースコードは、<code>parser.c</code>の生成に使用される。
このセクションでは、この生成プロセスのいくつかの重要な部分について説明する。</p>
<!-- textlint-disable -->
<h3><a class="header" href="#文法のパース" id="文法のパース">文法のパース</a></h3>
<p>はじめに、Tree-sitterは<code>grammar.js</code>のJavaScriptコードを評価し、文法をJSON形式に変換する必要がある。
これは<code>node</code>を使って行われる。 
文法のフォーマットは<a href="https://github.com/tree-sitter/tree-sitter/blob/master/cli/src/generate/grammar-schema.json">grammar-schema.json</a>によって規定される。
パースは<a href="https://github.com/tree-sitter/tree-sitter/blob/master/cli/src/generate/parse_grammar.rs">parse_grammar.rs</a>に実装される。</p>
<h3><a class="header" href="#文法ルール" id="文法ルール">文法ルール</a></h3>
<p>tree-sitterの文法はルールの集合からなる
。これらのルールは、構文ノードが他の構文ノードからどのように構成されるかを記述するオブジェクトである。
ルールにはいくつかのタイプがある: シンボル、文字列、正規表現、シーケンス、選択、繰り返し、その他。
内部ではこれらはすべて<a href="https://github.com/tree-sitter/tree-sitter/blob/master/cli/src/generate/rules.rs"><code>Rule</code></a>と呼ばれる<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enum</a>を使って表現される。</p>
<h3><a class="header" href="#preparing-a-grammar" id="preparing-a-grammar">Preparing a Grammar</a></h3>
<p>一度文法が解析されると、パーサを生成するためにいくつかの方法で変換する必要がある。
各変換は<a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli/src/generate/prepare_grammar"><code>prepare_grammar</code></a>ディレクトリの中の
個々のファイルで実装され、最終的には<code>prepare_grammar/mod.rs</code>で統合される。</p>
<p>これらの変換の最後に、初期の文法は<em>構文文法</em>と<em>レキシカル文法の</em>2つの文法に分割される。
構文の文法は、言語の<a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols"><em>非終端記号</em></a>が
他の文法記号からどのように構成されるかを記述し、字句の文法は文法の<em>終端記号</em>（文字列と正規表現）が個々の文字からどのように構成されるかを記述する。</p>
<h3><a class="header" href="#building-parse-tables" id="building-parse-tables">Building Parse Tables</a></h3>
<h2><a class="header" href="#the-runtime" id="the-runtime">The Runtime</a></h2>
<p>WIP</p>
<!-- textlint-enable -->
<p><a href="./section-4-syntax-highlighting.html">前のページ(シンタックスハイライター)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-6-contributing.html">次のページ(コントリビュート)</a></p>
<p><a href="./section-5-implementation.html">前のページ(Tree-sitterの実装)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-7-playground.html">次のページ(Playground)</a></p>
<!-- textlint-disable -->
<h1><a class="header" href="#コントリビュート" id="コントリビュート">コントリビュート</a></h1>
<h2><a class="header" href="#code-of-conduct" id="code-of-conduct">Code of Conduct</a></h2>
<p>Tree-sitterへのコントリビュータは<a href="https://www.contributor-covenant.org/version/1/4/code-of-conduct">Contributor Covenant</a>を遵守してください。</p>
<h2><a class="header" href="#tree-sitterの開発" id="tree-sitterの開発">Tree-sitterの開発</a></h2>
<h3><a class="header" href="#事前条件" id="事前条件">事前条件</a></h3>
<p>tree-sitterを変更するには、以下が必要です:</p>
<ol>
<li>コアライブラリや生成されたパーサをコンパイルするためのCコンパイラ。</li>
<li>Rustバインディングのコンパイル・ハイライトのライブラリ・CLIのコンパイルに必要な<a href="https://rustup.rs/">Rustツールチェイン</a>。</li>
<li>grammer.jsファイルからパーサを生成するために必要なNode.jsとNPM。</li>
<li>WASMライブラリをビルドするために、<a href="https://emscripten.org/">Emscripten</a>または<a href="https://www.docker.com/">Docker</a>がインストールされているか。</li>
</ol>
<h3><a class="header" href="#ビルド" id="ビルド">ビルド</a></h3>
<p>リポジトリをクローンする。</p>
<pre><code class="language-sh">git clone https://github.com/tree-sitter/tree-sitter
cd tree-sitter
</code></pre>
<p>(任意)WASMライブラリをビルドする。
もしこのステップをスキップすると、<code>tree-sitter playground</code>コマンドの実行にはインターネット接続が必要になります。
Emscriptenがインストールされている場合、<code>emcc</code>コンパイラが使用されます。それ以外の場合、Dockerが使用されます。</p>
<pre><code class="language-sh">./script/build-wasm
</code></pre>
<p>RustライブラリとCLIをビルドする。</p>
<pre><code class="language-sh">cargo build --release
</code></pre>
<p>これにより、<code>target/release</code>フォルダに<code>tree-sitter</code>CLI実行ファイルが作成されます。</p>
<h3><a class="header" href="#テスト" id="テスト">テスト</a></h3>
<p>テストが実行可能になる前に、テストに使用されるいくつかの文法をクローンする必要があります。</p>
<pre><code class="language-sh">script/fetch-fixtures
</code></pre>
<p>CLIに施した変更をテストするために、現在のCLIコードを使用してこれらのパーサを再生成します。</p>
<pre><code class="language-sh">script/generate-fixtures
</code></pre>
<p>その後、テストを実行できます。</p>
<pre><code class="language-sh">script/test
</code></pre>
<p>同様に、WASMバインディングをテストするには、これらのパーサをWASMにコンパイルする必要があります。</p>
<pre><code class="language-sh">script/generate-fixtures-wasm
script/test-wasm
</code></pre>
<h3><a class="header" href="#デバッグ" id="デバッグ">デバッグ</a></h3>
<p>テストスクリプトはいくつかの便利なフラグを持っています。
<code>script/test -h</code>を実行することですべてのフラグの一覧を確認できます。
以下は主なフラグの一部です。</p>
<p>特定のユニットテストを実行したい場合は、その名前（またはその一部）を引数として渡します。</p>
<pre><code class="language-sh">script/test test_does_something
</code></pre>
<p>-gフラグを使用してデバッガ（<code>lldb</code>または<code>gdb</code>）でテストを実行できます。</p>
<pre><code class="language-sh">script/test test_does_something -g
</code></pre>
<p>Tree-sitterのテストスイートの一部は、いくつかの異なる言語のコーパステストを解析し、コーパス内の各例に対してランダムな編集を行うことです。
特定の言語のテストのみを実行したい場合は、<code>-l</code>フラグを渡します。
また、コーパスから特定の_例_を実行したい場合は、<code>-e</code>フラグを渡します。</p>
<pre><code class="language-sh">script/test -l javascript -e Arrays
</code></pre>
<h2><a class="header" href="#パッケージの公開" id="パッケージの公開">パッケージの公開</a></h2>
<p>メインリポジトリである<a href="https://github.com/tree-sitter/tree-sitter"><code>tree-sitter/tree-sitter</code></a>は、さまざまな言語のパッケージレジストリに公開されているいくつかのパッケージのソースコードを含んでいます。</p>
<ul>
<li>Rustクレート <a href="https://crates.io">crates.io</a>:
<ul>
<li><a href="https://crates.io/crates/tree-sitter"><code>tree-sitter</code></a> - Rustバインディング</li>
<li><a href="https://crates.io/crates/tree-sitter-highlight"><code>tree-sitter-highlight</code></a> - シンタックスハイライトのライブラリ</li>
<li><a href="https://crates.io/crates/tree-sitter-cli"><code>tree-sitter-cli</code></a> - コマンドラインツール</li>
</ul>
</li>
<li>JavaScriptモジュール <a href="https://npmjs.com">npmjs.com</a>:
<ul>
<li><a href="https://www.npmjs.com/package/web-tree-sitter"><code>web-tree-sitter</code></a> - コアライブラリ向けWASMベースのJavaScriptバインディング</li>
<li><a href="https://www.npmjs.com/package/tree-sitter-cli"><code>tree-sitter-cli</code></a> - コマンドラインツール</li>
</ul>
</li>
</ul>
<p>さらに、他のいくつかの依存リポジトリには、別の公開パッケージが含まれています。</p>
<ul>
<li><a href="https://github.com/tree-sitter/node-tree-sitter"><code>tree-sitter/node-tree-sitter</code></a> - npmjs.comで<a href="https://www.npmjs.com/package/tree-sitter"><code>tree-sitter</code></a>として公開されているコアライブラリ向けのNode.jsバインディング</li>
<li><a href="https://github.com/tree-sitter/py-tree-sitter"><code>tree-sitter/py-tree-sitter</code></a> - <a href="https://pypi.org">PyPI.org</a>で<a href="https://pypi.org/project/tree-sitter"><code>tree-sitter</code></a>として公開されているコアライブラリ向けのPythonバインディング</li>
</ul>
<h2><a class="header" href="#新リリースの公開" id="新リリースの公開">新リリースの公開</a></h2>
<p>CLIの新リリースを公開するには、以下の手順が必要です。</p>
<ol>
<li>
<p>すべての変更をコミットしてプッシュし、CIが成功することを確認します。</p>
<pre><code class="language-sh">git commit -m &quot;Fix things&quot;
git push
</code></pre>
</li>
<li>
<p>新しいタグを作成します。</p>
<pre><code class="language-sh">script/version patch
</code></pre>
</li>
</ol>
<p>これは、現在のバージョンを決定し、_patch_バージョン番号を増やし、RustとNode CLIパッケージの<code>Cargo.toml</code>と<code>package.json</code>ファイルを更新します。
その後、新しいバージョンのためのコミットとタグを作成します。
使用できる引数についての詳細は、<a href="https://docs.npmjs.com/cli/version"><code>npm version</code></a>コマンドのドキュメントを参照してください。</p>
<ol start="3">
<li>
<p>タグとコミットをプッシュします。</p>
<pre><code class="language-sh">git push
git push --tags
</code></pre>
</li>
<li>
<p>CIが成功するのを待ちます。
gitタグのため、CIジョブはアーティファクトを<a href="https://github.com/tree-sitter/tree-sitter/releases">GitHubリリース</a>を公開します。
<code>tree-sitter-cli</code>のnpmモジュールは、インストール中に対応するGitHubリリースから適切なバイナリをダウンロードすることで動作します。
そのため、バイナリがアップロードされるまでnpmパッケージを公開しない方が良いです。</p>
</li>
<li>
<p>npmパッケージを公開します。</p>
<pre><code class="language-sh">cd cli/npm
npm publish
</code></pre>
</li>
</ol>
<!-- textlint-enable -->
<p><a href="./section-5-implementation.html">前のページ(Tree-sitterの実装)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-7-playground.html">次のページ(Playground)</a></p>
<p>公式ドキュメントの<a href="https://tree-sitter.github.io/tree-sitter/playground">Playground</a>より、WebブラウザでTree-sitterを利用できる。</p>
<p><a href="./section-6-contributing.html">前のページ(コントリビュート)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-8-code-navigation-systems.html">次のページ(Code Navigation Systems)</a></p>
<!-- textlint-disable -->
<p><a href="./section-7-playground.html">前のページ(Playground)</a> &lt;---- <a href="../README.html">目次</a></p>
<h1><a class="header" href="#コードナビゲーションシステム" id="コードナビゲーションシステム">コードナビゲーションシステム</a></h1>
<p>Tree-sitterは、コードナビゲーションシステムの一部として、
<a href="https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries">tree query language</a>を使用できます。
そのようなシステムの例として、<code>tree-sitter tags</code>コマンドがあります。
このコマンドは、ファイル引数内の特定の構文ノードをテキスト形式で出力します。
この機能の利用例として、GitHubの<a href="https://docs.github.com/en/repositories/working-with-files/using-files/navigating-code-on-github#precise-and-search-based-navigation">search-based code navigation</a>があります。
このドキュメントは、このようなシステムとの統合方法、およびTree-sitterの文法を持つ任意の言語にこの機能を拡張する方法について説明します。</p>
<h2><a class="header" href="#タグ付けとキャプチャ" id="タグ付けとキャプチャ">タグ付けとキャプチャ</a></h2>
<p>タグ付けとは、プログラムで名前を付けられるエンティティを特定することです。
Tree-sitterのクエリを使用してこれらのエンティティを見つけたら、構文キャプチャを使用してエンティティとその名前をラベル付けします。</p>
<p>特定のタグ付けの本質は、一致したエンティティの_役割_（つまり、定義か参照か）と、そのエンティティの_種類_の2つのデータです。
種類は、エンティティがどのように使用されるかを説明します（クラス定義、関数呼び出し、変数参照など）。
慣習的に、<code>@role.kind</code>キャプチャ名形式に続く構文キャプチャを使用し、常に<code>@name</code>と呼ばれる別の内部キャプチャを使用して、特定の識別子の名前を取り出します。</p>
<p>オプションで、docstringを紐づけるに<code>@doc</code>という名前のキャプチャを含めることができます。
便宜上、タグ付けシステムは、コメント構文をdocstringから削除するのに便利な2つの組み込み関数、
<code>#select-adjacent!</code>と<code>#strip!</code>を提供します。
<code>#strip!</code>は、最初の引数としてキャプチャを取り、2番目に引数として正規表現を取り、クォートされた文字列として表現します。
正規表現に一致するテキストパターンは、渡されたキャプチャに関連付けられたテキストから削除されます。
<code>#select-adjacent!</code>は、2つのキャプチャ名を渡すと、最初のキャプチャに関連付けられたテキストをフィルタリングし、2番目のキャプチャに隣接するノードのみを保持します。
これは、一致したコメントに含まれる情報が多すぎる場合に便利です。</p>
<h2><a class="header" href="#例-4" id="例-4">例</a></h2>
<p>この<a href="https://github.com/tree-sitter/tree-sitter-python/blob/78c4e9b6b2f08e1be23b541ffced47b15e2972ad/queries/tags.scm#L4-L5">クエリ</a>は
Pythonの関数定義を認識し、宣言された名前をキャプチャします。
<code>function_definition</code>構文ノードは、<a href="https://github.com/tree-sitter/tree-sitter-python/blob/78c4e9b6b2f08e1be23b541ffced47b15e2972ad/grammar.js#L354">Python Tree-sitterの文法</a>で定義されています。</p>
<pre><code class="language-scheme">(function_definition
  name: (identifier) @name) @definition.function
</code></pre>
<p>より洗練されたクエリは、<a href="https://github.com/tree-sitter/tree-sitter-javascript/blob/fdeb68ac8d2bd5a78b943528bb68ceda3aade2eb/queries/tags.scm#L63-L70">JavaScript Tree-sitterリポジトリ</a>にあります。</p>
<pre><code class="language-scheme">(assignment_expression
  left: [
    (identifier) @name
    (member_expression
      property: (property_identifier) @name)
  ]
  right: [(arrow_function) (function)]
) @definition.function
</code></pre>
<p>更に洗練されたクエリは、<a href="https://github.com/tree-sitter/tree-sitter-ruby/blob/1ebfdb288842dae5a9233e2509a135949023dd82/queries/tags.scm#L24-L43">Ruby Tree-sitterリポジトリ</a>にあります。
このクエリは、Rubyのクラスまたはシングルトンクラス宣言に関連付けられたdocstringからRubyコメント文字(<code>#</code>)を削除するための組み込み関数を使用し、<code>@definition.class</code>として一致したノードに隣接するdocstringのみを選択します。</p>
<pre><code class="language-scheme">(
  (comment)* @doc
  .
  [
    (class
      name: [
        (constant) @name
        (scope_resolution
          name: (_) @name)
      ]) @definition.class
    (singleton_class
      value: [
        (constant) @name
        (scope_resolution
          name: (_) @name)
      ]) @definition.class
  ]
  (#strip! @doc &quot;^#\\s*&quot;)
  (#select-adjacent! @doc @definition.class)
)
</code></pre>
<p>以下の表は、タグ付けプロセス中の種類と役割の標準的な語彙を説明しています。
新しいアプリケーションは、これらのキャプチャ名を拡張（またはそのサブセットのみを認識）することができますが、以下の名前を標準化することが望ましいです。</p>
<table><thead><tr><th>カテゴリ</th><th>タグ</th></tr></thead><tbody>
<tr><td>Class definitions</td><td><code>@definition.class</code></td></tr>
<tr><td>Function definitions</td><td><code>@definition.function</code></td></tr>
<tr><td>Interface definitions</td><td><code>@definition.interface</code></td></tr>
<tr><td>Method definitions</td><td><code>@definition.method</code></td></tr>
<tr><td>Module definitions</td><td><code>@definition.module</code></td></tr>
<tr><td>Function/method calls</td><td><code>@reference.call</code></td></tr>
<tr><td>Class reference</td><td><code>@reference.class</code></td></tr>
<tr><td>Interface implementation</td><td><code>@reference.implementation</code></td></tr>
</tbody></table>
<h2><a class="header" href="#コマンドライン呼び出し" id="コマンドライン呼び出し">コマンドライン呼び出し</a></h2>
<p><code>tree-sitter tags</code>コマンドを使用して、タグクエリファイルをテストし、タグ付けするファイルを1つ以上の引数として渡すことができます。
Tree-sitter Rubyリポジトリ内から、<code>test.rb</code>というファイルに対してこのツールを実行できます。</p>
<pre><code class="language-ruby">module Foo
  class Bar
    # won't be included

    # is adjacent, will be
    def baz
    end
  end
end
</code></pre>
<p><code>tree-sitter tags test.rb</code>を呼び出すと、一致したエンティティの名前、役割、場所、最初の行、およびdocstringを示す情報が表示されます。
下記は、コンソール出力の例です。</p>
<pre><code>    test.rb
        Foo              | module       def (0, 7) - (0, 10) `module Foo`
        Bar              | class        def (1, 8) - (1, 11) `class Bar`
        baz              | method       def (2, 8) - (2, 11) `def baz`  &quot;is adjacent, will be&quot;
</code></pre>
<p>各言語のレポジトリの<code>queries/tags.scm</code>に、その言語のタグクエリが配置するのが良いでしょう。</p>
<h2><a class="header" href="#ユニットテスト-1" id="ユニットテスト-1">ユニットテスト</a></h2>
<p>タグクエリは、<code>tree-sitter test</code>を使用してテストできます。
<code>test/tags/</code>の下のファイルは、<a href="https://tree-sitter.github.io/tree-sitter/syntax-highlighting#unit-testing">ハイライトクエリ</a>と同じコメントシステムを使用してチェックされます。
たとえば、上記のRubyタグは、次のコメントを使用してテストできます。</p>
<pre><code class="language-ruby">module Foo
  #     ^ definition.module
  class Bar
    #    ^ definition.class

    def baz
      #  ^ definition.method
    end
  end
end
</code></pre>
<p><a href="./section-7-playground.html">前のページ(Playground)</a> &lt;---- <a href="../README.html">目次</a></p>
<!-- textlint-enable -->
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
            window.clip_buttons = true;
            window.tryit_buttons = false;
            window.side_bar = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
