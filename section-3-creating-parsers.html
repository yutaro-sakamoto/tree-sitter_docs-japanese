<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>パーサを作る - My first Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">概要</a></li><li class="chapter-item expanded "><a href="section-2-using-parsers.html"><strong aria-hidden="true">1.</strong> パーサを使う</a></li><li class="chapter-item expanded "><a href="section-3-creating-parsers.html" class="active"><strong aria-hidden="true">2.</strong> パーサを作る</a></li><li class="chapter-item expanded "><a href="section-4-syntax-highlighting.html"><strong aria-hidden="true">3.</strong> シンタックスハイライト</a></li><li class="chapter-item expanded "><a href="section-5-implementation.html"><strong aria-hidden="true">4.</strong> 実装</a></li><li class="chapter-item expanded "><a href="section-6-contributing.html"><strong aria-hidden="true">5.</strong> コントリビュート</a></li><li class="chapter-item expanded "><a href="section-7-playground.html"><strong aria-hidden="true">6.</strong> Playground</a></li><li class="chapter-item expanded "><a href="section-8-code-navigation-systems.html"><strong aria-hidden="true">7.</strong> コードナビゲーションシステム</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">My first Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="./section-2-using-parsers.html">前のページ(パーサを使う)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-4-syntax-highlighting.html">次のページ(シンタックスハイライター)</a></p>
<h1><a class="header" href="#パーサを作る" id="パーサを作る">パーサを作る</a></h1>
<p>Tree-sitterによるパーサの開発は学習が難しいものの、一度コツをつかめば楽しく、禅のような感覚さえ覚えるだろう。
このドキュメントは、開発を始め方を示し、開発を進める上での考え方を身につける一助となるだろう。</p>
<h2><a class="header" href="#はじめに" id="はじめに">はじめに</a></h2>
<h3><a class="header" href="#依存するソフトウェア" id="依存するソフトウェア">依存するソフトウェア</a></h3>
<p>Tree-sitterパーサを開発するためには、いくつかのソフトウェアをインストールする必要がある。</p>
<ul>
<li><strong>Node.js</strong> - Tree-sitterの文法規則はJavaScriptで記述され、Tree-sitterはJavascript処理系として<a href="https://nodejs.org/ja/">Node.js</a>を利用する。したがって、<code>node</code>コマンドの存在するディレクトリを環境変数<code>PATH</code>に追加する必要がある。また、Node.jsのバージョンが6.0以上であることも必要である。</li>
<li><strong>Cコンパイラ</strong> - Tree-sitterはC言語で記述されたパーサを生成する。パーサの実行とテストを行う<code>tree-sitter parse</code>と<code>tree-sitter test</code>コマンドを使うにはC/C++コンパイラがインストールされている必要がある。Tree-sitterは各プラットフォーム規定する標準的なディレクトリからC/C++コンパイラを検索して利用する。</li>
</ul>
<h3><a class="header" href="#インストール" id="インストール">インストール</a></h3>
<p>Tree-sitterパーサを生成するには、<a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli">the <code>tree-sitter</code> CLI</a>が必要であり、複数の方法でインストールできる。</p>
<ul>
<li><code>tree-sitter-cli</code> <a href="https://github.com/tree-sitter/tree-sitter/tree/master/cli">Rustクレート</a> をRustパッケージマネージャである<a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>cargo</code></a>を使ってソースコードからビルドする。これは任意のプラットフォームで有効なインストール方法である。詳細は<a href="./section-6-contributing.html">コントリビュート</a>を参照すること。
<code>tree-sitter-cli</code><a href="https://www.npmjs.com/package/tree-sitter-cli">Node.jsモジュール</a>をNodeパッケージマネージャの<a href="https://docs.npmjs.com/"><code>npm</code></a>を使ってインストールする。</li>
</ul>
<!-- textlint-disable -->
<p>この方法は手軽だが、pre-builtバイナリを使うため、限られたプラットフォームでのみ利用可能な方法である。</p>
<!-- textlint-enable -->
<ul>
<li>使用するプラットフォーム向けのバイナリを<a href="https://github.com/tree-sitter/tree-sitter/releases">最新のGitHubリリースページ</a>からダウンロードし、そのバイナリを格納したディレクトリのパスを環境変数<code>PATH</code>に追加する。</li>
</ul>
<h3><a class="header" href="#プロジェクトの新規作成" id="プロジェクトの新規作成">プロジェクトの新規作成</a></h3>
<!-- textlint-disable -->
<p>パーサのリポジトリ名は「tree-sitter-」後に言語名を付けたものが好ましい。</p>
<!-- textlint-enable -->
<pre><code class="language-sh">mkdir tree-sitter-${YOUR_LANGUAGE_NAME}
cd tree-sitter-${YOUR_LANGUAGE_NAME}
</code></pre>
<p><code>npm</code> コマンドを使って、プロジェクトに関する情報を格納する<code>package.json</code>を作成し、Node.jsから開発したパーサを利用できるようする。</p>
<pre><code class="language-sh"># 下記のコマンドでは、対話モードでプロジェクトに関する情報を入力する。
npm init

# 下記のコマンドにより、Nodeから開発したパーサを利用可能にするためのモジュールをインストールする。
npm install --save nan

# 下記のコマンドにより、Tree-sitter CLIをインストールする。
npm install --save-dev tree-sitter-cli
</code></pre>
<p>最後のコマンドにより、作業ディレクトリの<code>node_modules</code>ディレクトリにCLIツールをインストールする。
実行可能ファイル<code>tree-sitter</code>が<code>node_modules/.bin</code>ディレクトリに作成される。
Node.jsの慣習に従って、このフォルダを環境変数<code>PATH</code>に追加しておくと、このディレクトリで作業しているときに簡単にプログラムを実行できる。</p>
<pre><code class="language-sh"># In your shell profile script
export PATH=$PATH:./node_modules/.bin
</code></pre>
<p>CLIのインストールを完了したら、<code>grammar.js</code>に下記の内容を書き込む。</p>
<pre><code class="language-js">module.exports = grammar({
  name: 'YOUR_LANGUAGE_NAME',

  rules: {
    // TODO: add the actual grammar rules
    source_file: $ =&gt; 'hello'
  }
});
</code></pre>
<p>その後、下記のコマンドを実行する。</p>
<pre><code class="language-sh">tree-sitter generate
</code></pre>
<p>これは、この些細な言語を解析するのに必要なCコードと、このネイティブパーサーをNode.jsモジュールとしてコンパイルしてロードするために必要ないくつかのファイルを生成する。</p>
<p>下記のように「hello」と書き込まれたソースファイルを用意すれば、生成したパーサをテストできる。</p>
<pre><code class="language-sh">echo 'hello' &gt; example-file
tree-sitter parse example-file
</code></pre>
<p>WindowsのPowerShellを使う場合は下記のコマンドを実行する。</p>
<pre><code class="language-pwsh">&quot;hello&quot; | Out-File example-file -Encoding utf8
tree-sitter parse example-file
</code></pre>
<p>これにより、下記のメッセージが出力される。</p>
<pre><code>(source_file [0, 0] - [1, 0])
</code></pre>
<p>実際に動作するパーサを作成できた。</p>
<h2><a class="header" href="#tool-overview" id="tool-overview">Tool Overview</a></h2>
<p>コマンドラインツール<code>tree-sitter</code>の機能を紹介する。</p>
<h3><a class="header" href="#generateコマンド" id="generateコマンド"><code>generate</code>コマンド</a></h3>
<p>最も重要なのは<code>tree-sitter generate</code>コマンドである。
このコマンドはカレントディレクトリの<code>grammar.js</code>を読み込み、<code>src/parser.c</code>にパーサの実装を書き出す。
文法を変更したら、<code>tree-sitter generate</code>コマンドを再度実行する必要がある。</p>
<p><code>tree-sitter generate</code>を最初に実行したとき、下記のファイルも生成される。</p>
<ul>
<li><code>binding.gyp</code> -Node.jsが作成した言語をどのようにコンパイルするかが記述されるたファイル。</li>
<li><code>bindings/node/index.js</code> - 作成した言語を使用する際にNode.jsが内部で読み込むファイル。</li>
<li><code>bindings/node/binding.cc</code> - Node.jsが使用するJavaScriptオブジェクトのラッパーが記述されるたファイル。</li>
<li><code>bindings/rust/lib.rs</code> - 作成した言語をRustから利用するためのラッパーが記述されたファイル。</li>
<li><code>bindings/rust/build.rs</code> - Rustクレート向けのビルド処理が記述されるたファイル。</li>
<li><code>src/tree_sitter/parser.h</code> - 生成した<code>parser.c</code>が使用するヘッダファイル。</li>
</ul>
<p>文法に曖昧さや局所的な曖昧さ（原文：local ambiguity）がある場合、Tree-sitterはパーサの生成時にそれを検出し、
Unresolved conflictというエラーメッセージを表示して終了する。
これらのエラーの詳細については、以下を参照せよ。</p>
<h3><a class="header" href="#command-test" id="command-test">Command: <code>test</code></a></h3>
<p><code>tree-sitter test</code>コマンドを使ってパーサを簡単にテストできる。</p>
<p>新たな文法規則を追加するたびに、パースするたびに構文木がどのような形式になるかを検証するテストを作成すべきである。
これらのテストはプロジェクトルートの<code>corpus/</code>または<code>test/corpus/</code>ディレクトリ以下のテキストファイルに専用フォーマットで記述する。</p>
<p>例えば、下記の内容が書き込まれた<code>test/corpus/statements.txt</code>ファイルを考える。</p>
<pre><code>==================
Return statements
==================

func x() int {
  return 1;
}

---

(source_file
  (function_definition
    (identifier)
    (parameter_list)
    (primitive_type)
    (block
      (return_statement (number)))))
</code></pre>
<ul>
<li>
<p><code>=</code>がの間に<strong>テスト名</strong>を書く。</p>
</li>
<li>
<p>その後にパーサの<strong>入力</strong>となるソースコードを書き、3つ以上の<code>-</code>を含む行を書く。</p>
</li>
<li>
<p>その後に<strong>出力として期待される構文木</strong>を<a href="https://ja.wikipedia.org/wiki/S%E5%BC%8F"><code>S式</code></a>で書く。S式中の空白は無視されるが、理想的には構文木は読みやすい方が良い。S式は、<code>func</code>、<code>(</code>、<code>;</code>といった、分包機そうでは文字列や正規表現で表される構文ノードを表示しないことに注意せよ。構文木は、<a href="./section-2-using-parsers.html#%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E3%83%8E%E3%83%BC%E3%83%89%E3%81%A8%E5%8C%BF%E5%90%8D%E3%83%8E%E3%83%BC%E3%83%89">「パーサの使う」のこの節</a>で説明した名前付きノード*のみを表示する。</p>
<p>期待出力を示すセクションには、各子ノードに関連付けられた<a href="./using-parsers#node-field-names"><em>フィールド名</em></a>をオプションで表示できる。テストにフィールド名を含める場合、S式内のノードの前に、コロンに続いてノード自体を記述する前に、ノードのフィールド名を記述する。</p>
</li>
</ul>
<pre><code>(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    result: (primitive_type)
    body: (block
      (return_statement (number)))))
</code></pre>
<ul>
<li>もし言語の構文が<code>===</code>と<code>---</code>のテストセパレータと衝突する場合、同一のサフィックス（下記の例では<code>|||</code>）を追加して曖昧さを解消できる。</li>
</ul>
<pre><code>==================|||
Basic module
==================|||

---- MODULE Test ----
increment(n) == n + 1
====

---|||

(source_file
  (module (identifier)
    (operator (identifier)
      (parameter_list (identifier))
      (plus (identifier_ref) (number)))))
</code></pre>
<p>これらのテストは重要である。
テストはパーサのAPIドキュメントとして機能し、文法を変更するたびにすべてが正しくパースされていることを確認するために実行できる。</p>
<p>デフォルトで<code>tree-sitter test</code>コマンドは<code>corpus</code>または<code>test/corpus/</code>フォルダ内のすべてのテストを実行する。
特定のテストを実行するには、<code>-f</code>フラグを使う。</p>
<pre><code class="language-sh">tree-sitter test -f 'Return statements'
</code></pre>
<p>包括的なテストを追加することが推奨される。
もし非可視性のノードがある場合、<code>corpus</code>ディレクトリ内のテストファイルに追加することが良いだろう。
通常、各言語構造のすべての組み合わせをテストすることが良い。
これによりテストカバレッジが向上し、言語の「エッジ」を理解するための方法を読者に二重で提供できる。</p>
<!-- textlint-disable -->
<h4><a class="header" href="#自動コンパイル" id="自動コンパイル">自動コンパイル</a></h4>
<p><code>tree-sitter test</code>を実行するたびに、パーサのCコードを再コンパイルするので、最初の実行時には少し時間がかかる場合がある。
これは、Tree-sitterが自動的にCコードを動的ロード可能なライブラリにコンパイルするためである。
<code>tree-sitter generate</code>を再実行してパーサを更新するたびに、必要に応じてパーサを再コンパイルする。</p>
<h4><a class="header" href="#シンタックスハイライトのテスト" id="シンタックスハイライトのテスト">シンタックスハイライトのテスト</a></h4>
<p><code>tree-sitter test</code>コマンドは、<code>test/highlight</code>フォルダ内にシンタックスハイライトのテストが存在する場合、それらも実行する。
詳細は<a href="./syntax-highlighting#unit-testing">シンタックスハイライトのページ</a>を参照すること。</p>
<h3><a class="header" href="#parseコマンド" id="parseコマンド"><code>parse</code>コマンド</a></h3>
<p><code>tree-sitter parse</code>コマンドを使って任意のファイルをパースできる。
これにより、下記のような範囲とフィールド名を含む構文木が表示される。</p>
<pre><code>(source_file [0, 0] - [3, 0]
  (function_declaration [0, 0] - [2, 1]
    name: (identifier [0, 5] - [0, 9])
    parameters: (parameter_list [0, 9] - [0, 11])
    result: (type_identifier [0, 12] - [0, 15])
    body: (block [0, 16] - [2, 1]
      (return_statement [1, 2] - [1, 10]
        (expression_list [1, 9] - [1, 10]
          (int_literal [1, 9] - [1, 10]))))))
</code></pre>
<p><code>tree-sitter parse</code>コマンドには、任意のファイルパスとグロブパターンを渡すことができ、指定されたすべてのファイルを解析する。
パースエラーが発生した場合、コマンドはゼロ以外のステータスコードで終了する。
<code>--quiet</code>フラグを使用して、構文木の出力を抑制することもできる。
さらに、<code>--stat</code>フラグを使用すると、処理されたすべてのファイルに対する集計されたパース成功/失敗情報が出力される。
これにより、<code>tree-sitter parse</code>を二次的なテスト戦略として使用できるようになります。
つまり、多数のファイルがエラーなしでパースされることを確認できます。</p>
<pre><code class="language-sh">tree-sitter parse 'examples/**/*.go' --quiet --stat
</code></pre>
<h3><a class="header" href="#highlightコマンド" id="highlightコマンド"><code>highlight</code>コマンド</a></h3>
<p><code>tree-sitter highlight</code>コマンドを使って任意のファイルにシンタックスハイライトの処理を実行できる。
これにより、ターミナルに直接色を出力することも可能だし、<code>--html</code>フラグを渡すことでHTMLを生成することもできる。
詳細は<a href="./syntax-highlighting">シンタックスハイライトのページ</a>を参照すること。</p>
<h3><a class="header" href="#文法dsl" id="文法dsl">文法DSL</a></h3>
<p>下記は<code>grammar.js</code>で使用できる組み込み関数の一覧である。
これらの関数の使用例は、後のセクションで詳しく説明される。</p>
<ul>
<li><strong>シンボル(<code>$</code>オブジェクト)</strong> - すべての文法規則は、通常<code>$</code>と呼ばれるパラメータを取るJavaScript関数として記述される。<code>$.identifier</code>という構文は、規則内で他の文法シンボルを参照する方法である。<code>$.MISSING</code>または<code>$.UNEXPECTED</code>で始まる名前は、<code>tree-sitter test</code>コマンドに特別な意味があるため避けるべきである。</li>
<li><strong>文字列と正規表現リテラル</strong> - 文法の終端記号は、JavaScriptの文字列と正規表現を使って記述される。もちろん、パーサは実際にはJavaScriptの正規表現エンジンを使ってこれらの正規表現を評価しない。パーサは、各パーサの一部として独自の正規表現マッチングロジックを生成する。正規表現リテラルは、文法内で正規表現を書く便利な方法である。</li>
<li><strong>シーケンス: <code>seq(rule1, rule2, ...)</code></strong> - この関数は、他のルールに一つずつ順番にマッチするルールを作成する。これは<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF記法</a>で複数のシンボルを隣り合わせに書くのと同様である。</li>
<li><strong>選択: <code>choice(rule1, rule2, ...)</code></strong> - この関数は、可能なルールのセットの<em>1つ</em>にマッチするルールを作成する。引数の順序は重要ではない。これは、EBNF記法の<code>|</code>（パイプ）演算子に類似している。</li>
<li><strong>繰り返し: <code>repeat(rule)</code></strong> - この関数は、指定されたルールの<em>0個以上</em>の出現にマッチするルールを作成する。以前の<code>repeat</code>ルールは<code>repeat1</code>を使って実装されているが、非常に一般的であるため含まれている。</li>
<li>** 繰り返し1: <code>repeat1(rule)</code>** - この関数は、指定されたルールの<em>1個以上</em>の出現にマッチするルールを作成する。以前の<code>repeat</code>ルールは<code>repeat1</code>を使って実装されているが、非常に一般的であるため含まれている。</li>
<li><strong>オプション: <code>optional(rule)</code></strong> - この関数は、指定されたルールの<em>0個または1個</em>の出現にマッチするルールを作成する。これは、EBNF記法の<code>[x]</code>（角括弧）構文に類似している。</li>
<li><strong>優先: <code>prec(number, rule)</code></strong> - この関数は、指定されたルールに数値の優先度を付与し、パーサ生成時に<a href="https://en.wikipedia.org/wiki/LR_parser#Conflicts_in_the_constructed_tables"><em>LR(1)コンフリクト</em></a>を解決するために使用される。2つのルールが、1つのトークンの先読みを考慮して真の曖昧さまたは<em>局所的な</em>曖昧さを表す方法で重なる場合、Tree-sitterは、より高い優先度を持つルールをマッチングしてコンフリクトを解決しようとする。すべてのルールのデフォルトの優先度はゼロである。これは、Yacc文法の<a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html">優先度ディレクティブ</a>と同様に機能する。</li>
<li><strong>左結合 : <code>prec.left([number], rule)</code></strong> - この関数は、指定されたルールを左結合としてマークし（オプションで数値の優先度を適用）、LR(1)コンフリクトが発生した場合、すべてのルールが同じ数値の優先度を持つ場合、Tree-sitterはルールの結合性を参照する。左結合ルールがある場合、Tree-sitterは、より早く終了するルールをマッチングすることを優先する。これは、Yacc文法の<a href="https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html">結合性ディレクティブ</a>と同様に機能する。</li>
<li><strong>右結合 : <code>prec.right([number], rule)</code></strong> - この関数は<code>prec.left</code>と同様であるが、Tree-sitterに対して後で終了するルールをマッチングすることを優先するように指示する。</li>
<li><strong>動的優先度: <code>prec.dynamic(number, rule)</code></strong> - この関数はprecと類似するが、指定された数値の優先度が<em>パーサ生成時</em>ではなく<em>ランタイム</em>で適用される。これは、文法内の<code>conflicts</code>フィールドを使用してコンフリクトを動的に処理し、本当の<em>曖昧さ</em>がある場合にのみ必要である。複数のルールが正しく特定のコードにマッチする場合、Tree-sitterは、各ルールに関連付けられた動的優先度の合計を比較し、最も高い合計を持つものを選択する。これは、Bison文法の<a href="https://www.gnu.org/software/bison/manual/html_node/Generalized-LR-Parsing.html">動的優先度ディレクティブ</a>と似ている。</li>
<li><strong>Tokens : <code>token(rule)</code></strong> - This function marks the given rule as producing only a single token. Tree-sitter's default is to treat each String or RegExp literal in the grammar as a separate token. Each token is matched separately by the lexer and returned as its own leaf node in the tree. The <code>token</code> function allows you to express a complex rule using the functions described above (rather than as a single regular expression) but still have Tree-sitter treat it as a single token.</li>
<li><strong>Immediate Tokens : <code>token.immediate(rule)</code></strong> - Usually, whitespace (and any other extras, such as comments) is optional before each token. This function means that the token will only match if there is no whitespace.</li>
<li><strong>Aliases : <code>alias(rule, name)</code></strong> - This function causes the given rule to <em>appear</em> with an alternative name in the syntax tree. If <code>name</code> is a <em>symbol</em>, as in <code>alias($.foo, $.bar)</code>, then the aliased rule will <em>appear</em> as a <a href="./using-parsers#named-vs-anonymous-nodes">named node</a> called <code>bar</code>. And if <code>name</code> is a <em>string literal</em>, as in <code>alias($.foo, 'bar')</code>, then the aliased rule will appear as an <a href="./using-parsers#named-vs-anonymous-nodes">anonymous node</a>, as if the rule had been written as the simple string.</li>
<li><strong>Field Names : <code>field(name, rule)</code></strong> - This function assigns a <em>field name</em> to the child node(s) matched by the given rule. In the resulting syntax tree, you can then use that field name to access specific children.</li>
</ul>
<p>In addition to the <code>name</code> and <code>rules</code> fields, grammars have a few other optional public fields that influence the behavior of the parser.</p>
<ul>
<li><strong><code>extras</code></strong> - an array of tokens that may appear <em>anywhere</em> in the language. This is often used for whitespace and comments. The default value of <code>extras</code> is to accept whitespace. To control whitespace explicitly, specify <code>extras: $ =&gt; []</code> in your grammar.</li>
<li><strong><code>inline</code></strong> - an array of rule names that should be automatically <em>removed</em> from the grammar by replacing all of their usages with a copy of their definition. This is useful for rules that are used in multiple places but for which you <em>don't</em> want to create syntax tree nodes at runtime.</li>
<li><strong><code>conflicts</code></strong> - an array of arrays of rule names. Each inner array represents a set of rules that's involved in an <em>LR(1) conflict</em> that is <em>intended to exist</em> in the grammar. When these conflicts occur at runtime, Tree-sitter will use the GLR algorithm to explore all of the possible interpretations. If <em>multiple</em> parses end up succeeding, Tree-sitter will pick the subtree whose corresponding rule has the highest total <em>dynamic precedence</em>.</li>
<li><strong><code>externals</code></strong> - an array of token names which can be returned by an <a href="#external-scanners"><em>external scanner</em></a>. External scanners allow you to write custom C code which runs during the lexing process in order to handle lexical rules (e.g. Python's indentation tokens) that cannot be described by regular expressions.</li>
<li><strong><code>precedences</code></strong> - an array of array of strings, where each array of strings defines named precedence levels in descending order. These names can be used in the <code>prec</code> functions to define precedence relative only to other names in the array, rather than globally. Can only be used with parse precedence, not lexical precedence.</li>
<li><strong><code>word</code></strong> - the name of a token that will match keywords for the purpose of the <a href="#keyword-extraction">keyword extraction</a> optimization.</li>
<li><strong><code>supertypes</code></strong> an array of hidden rule names which should be considered to be 'supertypes' in the generated <a href="./using-parsers#static-node-types"><em>node types</em> file</a>.</li>
</ul>
<h2><a class="header" href="#文法を記述する" id="文法を記述する">文法を記述する</a></h2>
<p>文法の記述には創造性が必要である。与えられた言語を記述するために使用できるCFG（文脈自由文法）は無限に存在する。良いTree-sitterパーサを作成するためには、2つの重要な特性を持つ文法を作成する必要がある。</p>
<ol>
<li>
<p><strong>直感的な構造</strong> - Tree-sitterの出力は<a href="https://en.wikipedia.org/wiki/Parse_tree">具象構文木</a>であり、木の各ノードは文法内の<a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols">端末記号または非端末記号</a>に直接対応している。したがって、解析しやすい木を生成するためには、文法内の記号と言語内の認識可能な構造との間に直接的な対応関係がある必要がある。これは当たり前のことのように思えるかもしれないが、<a href="https://en.wikipedia.org/wiki/Programming_language_specification">言語仕様</a>や<a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>/<a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>パーサのような文脈で文脈自由文法が書かれる方法とは非常に異なる。</p>
</li>
<li>
<p><strong>LR(1)の遵守</strong> - Tree-sitterは<a href="https://en.wikipedia.org/wiki/GLR_parser">GLRパーサ</a>アルゴリズムに基づいている。これは、任意の文脈自由文法を処理できるが、<a href="https://en.wikipedia.org/wiki/LR_parser">LR(1)文法</a>と呼ばれる文脈自由文法のクラスで最も効率的に動作する。この点で、Tree-sitterの文法は<a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>や<a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>の文法に似ているが、<a href="http://www.antlr.org/">ANTLR文法</a>、<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammars</a>、または言語仕様で一般的に使用される<a href="https://en.wikipedia.org/wiki/Ambiguous_grammar">曖昧な文法</a>とは異なる。</p>
</li>
</ol>
<p>既存の文脈自由文法を直接Tree-sitterの文法形式に変換するだけでは、これらの2つの特性を満たすことはできない可能性が高い。多くの場合、次の種類の調整が必要となる。次のセクションでは、これらの調整について詳しく説明する。</p>
<h3><a class="header" href="#まず最初に遵守すべきルール" id="まず最初に遵守すべきルール">まず最初に遵守すべきルール</a></h3>
<p>構文解析しようとする言語に対して厳密な仕様を見つけることは、通常は良いアイデアである。
この仕様には、おそらく文脈自由文法が含まれているであろう。
このCFGのルールを読み進めると、複雑で循環的な関係のグラフが見つかるかもしれない。
このグラフをナビゲートする方法が不明確になるかもしれませんが、文法を定義する際にどのように進めるべきかを理解するために、このグラフを読み進めることが重要である。</p>
<p>言語は全く違った構造を持つが、その構造はしばしば<em>宣言</em>、<em>定義</em>、<em>文</em>、<em>式</em>、<em>型</em>、<em>パターン</em>のような似たようなグループに分類されることがある。
文法を記述する際に、これらの基本的な<em>グループ</em>の記号を含むだけの構造を作成することが最初のステップとして良い。
Goのような言語の場合、次のように始めることができる。</p>
<pre><code class="language-js">{
  // ...

  rules: {
    source_file: $ =&gt; repeat($._definition),

    _definition: $ =&gt; choice(
      $.function_definition
      // TODO: other kinds of definitions
    ),

    function_definition: $ =&gt; seq(
      'func',
      $.identifier,
      $.parameter_list,
      $._type,
      $.block
    ),

    parameter_list: $ =&gt; seq(
      '(',
       // TODO: parameters
      ')'
    ),

    _type: $ =&gt; choice(
      'bool'
      // TODO: other kinds of types
    ),

    block: $ =&gt; seq(
      '{',
      repeat($._statement),
      '}'
    ),

    _statement: $ =&gt; choice(
      $.return_statement
      // TODO: other kinds of statements
    ),

    return_statement: $ =&gt; seq(
      'return',
      $._expression,
      ';'
    ),

    _expression: $ =&gt; choice(
      $.identifier,
      $.number
      // TODO: other kinds of expressions
    ),

    identifier: $ =&gt; /[a-z]+/,

    number: $ =&gt; /\d+/
  }
}
</code></pre>
<p>この文法の詳細は後に説明するが、<code>TODO</code>コメントに焦点を当てると、全体的な戦略が<em>幅優先</em>であることがわかる。
特筆すべきは、この初期のスケルトンは、言語仕様の文脈自由文法の正確なサブセットに直接マッチする必要はないということである。
単に、できるだけシンプルで明確な方法で主要なルールのグループに触れるだけでよい。</p>
<p>With this structure in place, you can now freely decide what part of the grammar to flesh out next. For example, you might decide to start with <em>types</em>. One-by-one, you could define the rules for writing basic types and composing them into more complex types:</p>
<p>この構造ができたら、次にどの部分の文法を詳細にするかを自由に決定できる。
例えば、<em>型</em>から始める場合、一つずつ基本的な型を書くためのルールを定義し、それらをより複雑な型に組み合わせることができる。</p>
<pre><code class="language-js">{
  // ...

  _type: $ =&gt; choice(
    $.primitive_type,
    $.array_type,
    $.pointer_type
  ),

  primitive_type: $ =&gt; choice(
    'bool',
    'int'
  ),

  array_type: $ =&gt; seq(
    '[',
    ']',
    $._type
  ),

  pointer_type: $ =&gt; seq(
    '*',
    $._type
  )
}
</code></pre>
<p>型のサブ言語をさらに発展させた後、<em>文</em>や<em>式</em>に取り組むことに切り替えることができる。
<code>tree-sitter parse</code>を使用して実際のコードを解析して進捗状況を確認すると良い。</p>
<p><strong>そして、<code>corpus</code>フォルダ内の各ルールに対して必ずテストを追加すること</strong></p>
<h3><a class="header" href="#ルールの適切な構造化" id="ルールの適切な構造化">ルールの適切な構造化</a></h3>
<p><a href="https://github.com/tree-sitter/tree-sitter-javascript">Tree-sitter Javascript parser</a>の作業を始めたとする。
単純に、<a href="https://262.ecma-international.org/6.0/">ECMAScript Language Spec</a>の構造を直接反映しようとするかもしれない。
このアプローチの問題を説明するために、次のコード行を考えてみる。</p>
<pre><code class="language-js">return x + y;
</code></pre>
<p>仕様によると、この行は<code>ReturnStatement</code>であり、フラグメント<code>x + y</code>は<code>AdditiveExpression</code>であり、<code>x</code>と<code>y</code>はどちらも<code>IdentifierReferences</code>である。
これらの構造の関係は、複雑な一連の生成規則によって表される。</p>
<pre><code>ReturnStatement          -&gt;  'return' Expression
Expression               -&gt;  AssignmentExpression
AssignmentExpression     -&gt;  ConditionalExpression
ConditionalExpression    -&gt;  LogicalORExpression
LogicalORExpression      -&gt;  LogicalANDExpression
LogicalANDExpression     -&gt;  BitwiseORExpression
BitwiseORExpression      -&gt;  BitwiseXORExpression
BitwiseXORExpression     -&gt;  BitwiseANDExpression
BitwiseANDExpression     -&gt;  EqualityExpression
EqualityExpression       -&gt;  RelationalExpression
RelationalExpression     -&gt;  ShiftExpression
ShiftExpression          -&gt;  AdditiveExpression
AdditiveExpression       -&gt;  MultiplicativeExpression
MultiplicativeExpression -&gt;  ExponentiationExpression
ExponentiationExpression -&gt;  UnaryExpression
UnaryExpression          -&gt;  UpdateExpression
UpdateExpression         -&gt;  LeftHandSideExpression
LeftHandSideExpression   -&gt;  NewExpression
NewExpression            -&gt;  MemberExpression
MemberExpression         -&gt;  PrimaryExpression
PrimaryExpression        -&gt;  IdentifierReference
</code></pre>
<p>言語仕様は、<code>IdentifierReference</code>と<code>Expression</code>の間に20の間接レベルを使用してJavaScript式の20の異なる優先度レベルをエンコードしている。
もし、言語仕様に従ってこのステートメントを表す具象構文木を作成すると、20のネストレベルがあり、実際のコードとは関係のない<code>BitwiseXORExpression</code>のような名前のノードが含まれる。</p>
<h3><a class="header" href="#優先度を使用する" id="優先度を使用する">優先度を使用する</a></h3>
<p>読みやすい構文木を生成するために、次のようなJavaScript式をより平らな構造でモデル化したい。</p>
<pre><code class="language-js">{
  // ...

  _expression: $ =&gt; choice(
    $.identifier,
    $.unary_expression,
    $.binary_expression,
    // ...
  ),

  unary_expression: $ =&gt; choice(
    seq('-', $._expression),
    seq('!', $._expression),
    // ...
  ),

  binary_expression: $ =&gt; choice(
    seq($._expression, '*', $._expression),
    seq($._expression, '+', $._expression),
    // ...
  ),
}
</code></pre>
<p>もちろん、この平坦な構造は非常に曖昧である。
もしパーサを生成しようとすると、Tree-sitterはエラーメッセージを表示する。</p>
<pre><code>Error: Unresolved conflict for symbol sequence:

  '-'  _expression  •  '*'  …

Possible interpretations:

  1:  '-'  (binary_expression  _expression  •  '*'  _expression)
  2:  (unary_expression  '-'  _expression)  •  '*'  …

Possible resolutions:

  1:  Specify a higher precedence in `binary_expression` than in the other rules.
  2:  Specify a higher precedence in `unary_expression` than in the other rules.
  3:  Specify a left or right associativity in `unary_expression`
  4:  Add a conflict for these rules: `binary_expression` `unary_expression`
</code></pre>
<p><code>-a * b</code>のような式では、<code>-</code>演算子が<code>a * b</code>に適用されるか、単に<code>a</code>に適用されるかが明確ではない。
これは、上記で説明した<code>prec</code>関数が役立つ場面である。
<code>prec</code>でルールをラップすることで、特定のシンボルのシーケンスが他のシーケンスよりも<em>密接に結びつく</em>べきであることを示すことができる。
例えば、<code>unary_expression</code>の<code>'-', $._expression</code>シーケンスは、<code>binary_expression</code>の<code>$._expression, '+', $._expression</code>シーケンスよりも密接に結びつくべきである。</p>
<pre><code class="language-js">{
  // ...

  unary_expression: $ =&gt; prec(2, choice(
    seq('-', $._expression),
    seq('!', $._expression),
    // ...
  ))
}
</code></pre>
<h3><a class="header" href="#using-associativity" id="using-associativity">Using Associativity</a></h3>
<p><code>unary_expression</code>の優先度を上げることで、このコンフリクトは解決されるが、別のコンフリクトが残る。</p>
<pre><code>Error: Unresolved conflict for symbol sequence:

  _expression  '*'  _expression  •  '*'  …

Possible interpretations:

  1:  _expression  '*'  (binary_expression  _expression  •  '*'  _expression)
  2:  (binary_expression  _expression  '*'  _expression)  •  '*'  …

Possible resolutions:

  1:  Specify a left or right associativity in `binary_expression`
  2:  Add a conflict for these rules: `binary_expression`
</code></pre>
<p><code>a * b * c</code>のような式では、<code>a * (b * c)</code>または<code>(a * b) * c</code>を意味するかが明確ではない。
これは<code>prec.left</code>と<code>prec.right</code>が使用される場面である。
ここでは2番目の解釈を選択したいので、<code>prec.left</code>を使用する。</p>
<pre><code class="language-js">{
  // ...

  binary_expression: $ =&gt; choice(
    prec.left(2, seq($._expression, '*', $._expression)),
    prec.left(1, seq($._expression, '+', $._expression)),
    // ...
  ),
}

```js
{
  // ...

  binary_expression: $ =&gt; choice(
    prec.left(2, seq($._expression, '*', $._expression)),
    prec.left(1, seq($._expression, '+', $._expression)),
    // ...
  ),
}
</code></pre>
<h3><a class="header" href="#隠蔽ルール" id="隠蔽ルール">隠蔽ルール</a></h3>
<p>上記の例では、<code>_expression</code>や<code>_type</code>のような構文ルールはアンダースコアから始まる。
アンダースコアから始まるルール名は、構文木で<em>隠される</em>。
これは、上記の文法の<code>_expression</code>のように常に単一の子ノードをラップするルールに便利である。
もしこれらのノードが隠されていない場合、構文木に大きな深さとノイズを追加し、理解が難しくなる。</p>
<h3><a class="header" href="#フィールドを使用する" id="フィールドを使用する">フィールドを使用する</a></h3>
<p>しばしば、構文ノードを解析する際に、順序付けられたリスト内の位置ではなく、名前で子ノードを参照できると便利である。
Tree-sitter文法は、<code>field</code>関数を使用してこれをサポートしています。
この関数を使用すると、ノードの一部またはすべての子に一意の名前を割り当てることができる。</p>
<pre><code class="language-js">function_definition: $ =&gt; seq(
  'func',
  field('name', $.identifier),
  field('parameters', $.parameter_list),
  field('return_type', $._type),
  field('body', $.block)
)
</code></pre>
<p>このようなフィールドを追加することで、<a href="./using-parsers#node-field-names">field API</a>を使用してノードを取得できるようになる。</p>
<h2><a class="header" href="#字句解析" id="字句解析">字句解析</a></h2>
<p>Tree-sitterの構文解析処理は、2つのフェーズに分かれている。
1つは構文解析（上記で説明した）で、もう1つは<a href="https://en.wikipedia.org/wiki/Lexical_analysis">字句解析</a>であり、字句解析は、個々の文字を言語の基本的な<em>トークン</em>にグループ化する処理である。
Tree-sitterの字句解析がどのように機能するかについて、いくつか重要なことがある。</p>
<h3><a class="header" href="#トークンの衝突" id="トークンの衝突">トークンの衝突</a></h3>
<p>文法はしばしば、同じ文字にマッチする複数のトークンを含んでいる。
例えば、文法には(<code>&quot;if&quot;</code>と<code>/[a-z]+/</code>)のトークンが含まれているかもしれない。
Tree-sitterは、これらのトークンの衝突をいくつかの方法で区別している。</p>
<ol>
<li>
<p><strong>外部スキャナー</strong> - 文法に外部スキャナーがある場合、<code>externals</code>配列内の1つ以上のトークンが現在の位置で有効である場合、外部スキャナーが常に最初に呼び出され、これらのトークンが存在するかどうかを決定する。</p>
</li>
<li>
<p><strong>Context-Aware Lexing</strong> - Tree-sitterは、パーサ実行時に必要に応じて字句解析を行う。ソースドキュメントの任意の位置で、字句解析器はその位置で<em>有効な</em>トークンのみを認識しようとする。</p>
</li>
<li>
<p><strong>Earliest Starting Position</strong> - Tree-sitterは、最初に開始された位置のトークンを優先する。これは、非常に許容的な正規表現（<code>/.*/</code>に類似）で最もよく見られ、貪欲で可能な限り多くのテキストを消費しようとする。この例では、正規表現は改行に達するまですべてのテキストを消費するが、その行のテキストが異なるトークンとして解釈できる場合でも、改行に達するまですべてのテキストを消費する。</p>
</li>
<li>
<p><strong>明示的な字句解析の優先度</strong> - 上記で説明した優先度関数が<code>token</code>関数内で使用されると、与えられた優先度値は字句解析器に対する指示として機能する。文書内の特定の位置で文字にマッチする2つの有効なトークンがある場合、Tree-sitterはより高い優先度を持つトークンを選択する。</p>
</li>
<li>
<p><strong>最長一致</strong> - もし複数の正当なトークンに同じ優先度で同じ場所でマッチした場合、Tree-sitterは最も長いものを選択する。</p>
</li>
<li>
<p><strong>Match Specificity</strong> - もし同じ優先度で同じ数の文字にマッチする2つの有効なトークンがある場合、Tree-sitterは、<code>String</code>として指定されたトークンを<code>RegExp</code>として指定されたトークンよりも優先する。</p>
</li>
<li>
<p><strong>ルールの表記順序</strong> - もし上記のいずれの基準も使用できない場合、Tree-sitterは文法内で先に現れるトークンを選択する。</p>
</li>
</ol>
<h3><a class="header" href="#字句解析の優先度と構文解析の優先度" id="字句解析の優先度と構文解析の優先度">字句解析の優先度と構文解析の優先度</a></h3>
<p>よくある間違いの一つに、字句解析の優先度と構文解析の優先度を区別しないことがある。
構文解析の優先度は、与えられたトークンの列を解釈するために選択されるルールを決定する。
字句解析の優先度は、与えられたテキストのセクションを解釈するために選択されるトークンを決定する。
字句解析の優先度は、構文解析の優先度よりも低いレベルで行われる。
上記のリストは、Tree-sitterの字句解析の優先度ルールを完全に捉えており、
おそらく他のどのセクションよりも頻繁にこのセクションを参照することになるでしょう。
ほとんどの場合、本当に行き詰まると、字句解析の優先度の問題に直面していることになります。
<code>prec</code>が<code>token</code>関数の中で使用されるか、外側で使用されるかによって、意味が異なることに特に注意してください。</p>
<h3><a class="header" href="#キーワード" id="キーワード">キーワード</a></h3>
<p>多くの言語では、一連の<em>キーワード</em>トークン（例：<code>if</code>、<code>for</code>、<code>return</code>）と、より一般的なトークン（例：<code>identifier</code>）があります。
このトークンは任意の単語にマッチし、キーワードにもマッチします。
例えば、JavaScriptには<code>instanceof</code>というキーワードがあり、次のように2項演算子として使用されます。</p>
<pre><code class="language-js">if (a instanceof Something) b();
</code></pre>
<p>しかし、次のコードは有効なJavaScriptではありません。</p>
<pre><code class="language-js">if (a instanceofSomething) b();
</code></pre>
<p><code>instanceof</code>のようなキーワードは、たとえ識別子がその位置で有効でない場合でも、他の文字が直後に続いてはなりません。
Tree-sitterは、<a href="#conflicting-tokens">上記</a>で説明したように、コンテキストに応じた字句解析を使用しているため、通常、この制限を課しません。
デフォルトでは、Tree-sitterは<code>instanceofSomething</code>を2つの別々のトークンとして認識します。
つまり<code>instanceof</code>キーワードの後に<code>identifier</code>が続くものと認識します。</p>
<h3><a class="header" href="#キーワード抽出" id="キーワード抽出">キーワード抽出</a></h3>
<p>幸い、Tree-sitterには、他の標準パーサの動作に合わせるためにこれを修正する<code>word</code>トークンという機能がある。
もし<code>word</code>トークンを文法で指定すると、Tree-sitterは<code>word</code>トークンにもマッチする文字列にマッチする<em>キーワード</em>トークンの集合を見つける。
その後、字句解析中に、各キーワードを個別にマッチさせる代わりに、Tree-sitterは<code>word</code>トークンを<em>最初に</em>マッチさせる2段階のプロセスを使用してキーワードをマッチさせます。</p>
<p>例えば、JavaScriptの文法に<code>identifier</code>を<code>word</code>トークンとして追加したとします。</p>
<pre><code class="language-js">grammar({
  name: 'javascript',

  word: $ =&gt; $.identifier,

  rules: {
    _expression: $ =&gt; choice(
      $.identifier,
      $.unary_expression,
      $.binary_expression
      // ...
    ),

    binary_expression: $ =&gt; choice(
      prec.left(1, seq($._expression, 'instanceof', $._expression)
      // ...
    ),

    unary_expression: $ =&gt; choice(
      prec.left(2, seq('typeof', $._expression))
      // ...
    ),

    identifier: $ =&gt; /[a-z_]+/
  }
});
</code></pre>
<p>Tree-sitterは、<code>typeof</code>と<code>instanceof</code>をキーワードとして識別します。
その後、上記の無効なコードを解析する際、<code>instanceof</code>トークンを個別にスキャンする代わりに、まず<code>identifier</code>をスキャンし、<code>instanceofSomething</code>を見つけます。
これにより、コードが無効であると正しく認識されます。</p>
<p>エラー検知に加えて、キーワード抽出にはパフォーマンスの利点もあります。
これにより、Tree-sitterはより小さく、シンプルな字句解析関数を生成できるため、<strong>パーサのコンパイルがはるかに速くなります</strong>。</p>
<h3><a class="header" href="#外部スキャナ" id="外部スキャナ">外部スキャナ</a></h3>
<p>多くの言語では、正規表現で記述することが不可能または不便なトークンがいくつかあります。例：</p>
<ul>
<li>Pythonの[インデント]</li>
<li>RubyやBashの<a href="https://en.wikipedia.org/wiki/Here_document">ヒアドキュメント</a></li>
<li>Rubyの<a href="https://docs.ruby-lang.org/en/2.5.0/doc/syntax/literals_rdoc.html#label-Percent+Strings">%文字列</a></li>
</ul>
<p>Tree-sitterは、これらの種類のトークンを扱うために<em>外部スキャナ</em>を使用することができます。
外部スキャナは、特定のトークンを認識するためのカスタムロジックを追加するために、文法の作者が手で書くことができるC関数のセットです。</p>
<p>外部スキャナを使うには、いくつかのステップが必要です。
まず、文法に<code>externals</code>セクションを追加します。
このセクションには、すべての外部トークンの名前をリストする必要があります。
これらの名前は、文法の他の場所で使用できます。</p>
<pre><code class="language-js">grammar({
  name: 'my_language',

  externals: $ =&gt; [
    $.indent,
    $.dedent,
    $.newline
  ],

  // ...
});
</code></pre>
<p>そして、プロジェクトに別のCまたはC++ソースファイルを追加します。
現在、CLIがそれを認識するためには、そのパスは<code>src/scanner.c</code>または<code>src/scanner.cc</code>である必要があります。
プロジェクトがNode.jsによってコンパイルされるときにそれが含まれるように、<code>binding.gyp</code>ファイルの<code>sources</code>セクションにこのファイルを追加し、
<code>bindings/rust/build.rs</code>ファイルの適切なブロックのコメント解除して、Rustクレートに含まれるようにしてください。</p>
<p>In this new source file, define an <a href="https://en.wikipedia.org/wiki/Enumerated_type#C"><code>enum</code></a> type containing the names of all of your external tokens. The ordering of this enum must match the order in your grammar's <code>externals</code> array; the actual names do not matter.</p>
<pre><code class="language-c">#include &lt;tree_sitter/parser.h&gt;

enum TokenType {
  INDENT,
  DEDENT,
  NEWLINE
}
</code></pre>
<p>Finally, you must define five functions with specific names, based on your language's name and five actions: <em>create</em>, <em>destroy</em>, <em>serialize</em>, <em>deserialize</em>, and <em>scan</em>. These functions must all use <a href="https://en.cppreference.com/w/cpp/language/language_linkage">C linkage</a>, so if you're writing the scanner in C++, you need to declare them with the <code>extern &quot;C&quot;</code> qualifier.</p>
<h4><a class="header" href="#create" id="create">Create</a></h4>
<pre><code class="language-c">void * tree_sitter_my_language_external_scanner_create() {
  // ...
}
</code></pre>
<p>This function should create your scanner object. It will only be called once anytime your language is set on a parser. Often, you will want to allocate memory on the heap and return a pointer to it. If your external scanner doesn't need to maintain any state, it's ok to return <code>NULL</code>.</p>
<h4><a class="header" href="#destroy" id="destroy">Destroy</a></h4>
<pre><code class="language-c">void tree_sitter_my_language_external_scanner_destroy(void *payload) {
  // ...
}
</code></pre>
<p>This function should free any memory used by your scanner. It is called once when a parser is deleted or assigned a different language. It receives as an argument the same pointer that was returned from the <em>create</em> function. If your <em>create</em> function didn't allocate any memory, this function can be a noop.</p>
<h4><a class="header" href="#serialize" id="serialize">Serialize</a></h4>
<pre><code class="language-c">unsigned tree_sitter_my_language_external_scanner_serialize(
  void *payload,
  char *buffer
) {
  // ...
}
</code></pre>
<p>This function should copy the complete state of your scanner into a given byte buffer, and return the number of bytes written. The function is called every time the external scanner successfully recognizes a token. It receives a pointer to your scanner and a pointer to a buffer. The maximum number of bytes that you can write is given by the <code>TREE_SITTER_SERIALIZATION_BUFFER_SIZE</code> constant, defined in the <code>tree_sitter/parser.h</code> header file.</p>
<p>The data that this function writes will ultimately be stored in the syntax tree so that the scanner can be restored to the right state when handling edits or ambiguities. For your parser to work correctly, the <code>serialize</code> function must store its entire state, and <code>deserialize</code> must restore the entire state. For good performance, you should design your scanner so that its state can be serialized as quickly and compactly as possible.</p>
<h4><a class="header" href="#deserialize" id="deserialize">Deserialize</a></h4>
<pre><code class="language-c">void tree_sitter_my_language_external_scanner_deserialize(
  void *payload,
  const char *buffer,
  unsigned length
) {
  // ...
}
</code></pre>
<p>This function should <em>restore</em> the state of your scanner based the bytes that were previously written by the <code>serialize</code> function. It is called with a pointer to your scanner, a pointer to the buffer of bytes, and the number of bytes that should be read.
It is good practice to explicitly erase your scanner state variables at the start of this function, before restoring their values from the byte buffer.</p>
<h4><a class="header" href="#scan" id="scan">Scan</a></h4>
<pre><code class="language-c">bool tree_sitter_my_language_external_scanner_scan(
  void *payload,
  TSLexer *lexer,
  const bool *valid_symbols
) {
  // ...
}
</code></pre>
<p>This function is responsible for recognizing external tokens. It should return <code>true</code> if a token was recognized, and <code>false</code> otherwise. It is called with a &quot;lexer&quot; struct with the following fields:</p>
<ul>
<li><strong><code>int32_t lookahead</code></strong> - The current next character in the input stream, represented as a 32-bit unicode code point.</li>
<li><strong><code>TSSymbol result_symbol</code></strong> - The symbol that was recognized. Your scan function should <em>assign</em> to this field one of the values from the <code>TokenType</code> enum, described above.</li>
<li><strong><code>void (*advance)(TSLexer *, bool skip)</code></strong> - A function for advancing to the next character. If you pass <code>true</code> for the second argument, the current character will be treated as whitespace; whitespace won't be included in the text range associated with tokens emitted by the external scanner.</li>
<li><strong><code>void (*mark_end)(TSLexer *)</code></strong> - A function for marking the end of the recognized token. This allows matching tokens that require multiple characters of lookahead. By default (if you don't call <code>mark_end</code>), any character that you moved past using the <code>advance</code> function will be included in the size of the token. But once you call <code>mark_end</code>, then any later calls to <code>advance</code> will <em>not</em> increase the size of the returned token. You can call <code>mark_end</code> multiple times to increase the size of the token.</li>
<li><strong><code>uint32_t (*get_column)(TSLexer *)</code></strong> - A function for querying the current column position of the lexer. It returns the number of codepoints since the start of the current line. The codepoint position is recalculated on every call to this function by reading from the start of the line.</li>
<li><strong><code>bool (*is_at_included_range_start)(const TSLexer *)</code></strong> - A function for checking whether the parser has just skipped some characters in the document. When parsing an embedded document using the <code>ts_parser_set_included_ranges</code> function (described in the <a href="./using-parsers#multi-language-documents">multi-language document section</a>), your scanner may want to apply some special behavior when moving to a disjoint part of the document. For example, in <a href="https://ejs.co">EJS documents</a>, the JavaScript parser uses this function to enable inserting automatic semicolon tokens in between the code directives, delimited by <code>&lt;%</code> and <code>%&gt;</code>.</li>
<li><strong><code>bool (*eof)(const TSLexer *)</code></strong> - A function for determining whether the lexer is at the end of the file. The value of <code>lookahead</code> will be <code>0</code> at the end of a file, but this function should be used instead of checking for that value because the <code>0</code> or &quot;NUL&quot; value is also a valid character that could be present in the file being parsed.</li>
</ul>
<p>The third argument to the <code>scan</code> function is an array of booleans that indicates which of your external tokens are currently expected by the parser. You should only look for a given token if it is valid according to this array. At the same time, you cannot backtrack, so you may need to combine certain pieces of logic.</p>
<pre><code class="language-c">if (valid_symbols[INDENT] || valid_symbol[DEDENT]) {

  // ... logic that is common to both `INDENT` and `DEDENT`

  if (valid_symbols[INDENT]) {

    // ... logic that is specific to `INDENT`

    lexer-&gt;result_symbol = INDENT;
    return true;
  }
}
</code></pre>
<h4><a class="header" href="#other-external-scanner-details" id="other-external-scanner-details">Other External Scanner Details</a></h4>
<p>If a token in your <code>externals</code> array is valid at the current position in the parse, your external scanner will be called first before anything else is done.
This means your external scanner functions as a powerful override of tree-sitter's lexing behavior, and can be used to solve problems that can't be cracked with ordinary lexical, parse, or dynamic precedence.</p>
<p>If a syntax error is encountered during regular parsing, tree-sitter's first action during error recovery will be to call your external scanner's <code>scan</code> function with all tokens marked valid.
Your scanner should detect this case and handle it appropriately.
One simple method of detection is to add an unused token to the end of your <code>externals</code> array, for example <code>externals: $ =&gt; [$.token1, $.token2, $.error_sentinel]</code>, then check whether that token is marked valid to determine whether tree-sitter is in error correction mode.</p>
<p>If you put terminal keywords in your <code>externals</code> array, for example <code>externals: $ =&gt; ['if', 'then', 'else']</code>, then any time those terminals are present in your grammar they will be tokenized by your external scanner.
It is equivalent to writing <code>externals: [$.if_keyword, $.then_keyword, $.else_keyword]</code> then using <code>alias($.if_keyword, 'if')</code> in your grammar.</p>
<p>External scanners are a common cause of infinite loops.
Be very careful when emitting zero-width tokens from your external scanner, and if you consume characters in a loop be sure use the <code>eof</code> function to check whether you are at the end of the file.</p>
<!-- textlint-enable -->
<p><a href="./section-2-using-parsers.html">前のページ(パーサを使う)</a> &lt;---- <a href="../README.html">目次</a> ----&gt; <a href="./section-4-syntax-highlighting.html">次のページ(シンタックスハイライター)</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="section-2-using-parsers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="section-4-syntax-highlighting.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="section-2-using-parsers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="section-4-syntax-highlighting.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
            window.clip_buttons = true;
            window.tryit_buttons = false;
            window.side_bar = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
